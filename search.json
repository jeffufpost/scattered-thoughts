[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Homepage\nElectrical engineer by background, but enthusiast of all things data, electronics, governance, development, global health, skiing, football, and many other things."
  },
  {
    "objectID": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#motivation-for-write-up",
    "href": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 3",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 3rd part of a multi-part series blog post on modeling in epidemiology.\nThe COVID-19 pandemic has brought a lot of attention to study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on two key points.\nAfter introducing the concepts of compartmentalization and disease dynamics in the first blog post, the second part looked at a deterministic numerical solution for the SEIR model discussed, and the effects of the parameters \\(\\beta\\), \\(\\sigma\\), and \\(\\gamma\\).\nWhile arguments can be made that the compartments themselves don’t reflect the reality of COVID-19, this is not the point of this discussion; I want to focus on the idea that the population level dynamics forget about the individual progression of the disease.\nWith this mind, this third part is going to discuss the problems that arise when averaging the latent period (\\(\\frac{1}{\\sigma}\\)) and infectious period (\\(\\frac{1}{\\gamma}\\)) on the simulations.\nLet’s have a look at the individual progression of disease to understand what is wrong."
  },
  {
    "objectID": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#implications-of-deterministic-model",
    "href": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#implications-of-deterministic-model",
    "title": "Epidemic modeling - Part 3",
    "section": "Implications of deterministic model",
    "text": "Implications of deterministic model\n\n\nCode\n# Import required libraries\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom scipy.stats import poisson\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\n\nfrom prettytable import PrettyTable\nimport math\n\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\n\n\n\n\n\n\nCode\ndef seir_model(init, parms, days):\n    S_0, E_0, I_0, R_0 = init\n    Epd, Ipd, Rpd = [0], [0], [0]\n    S, E, I, R = [S_0], [E_0], [I_0], [R_0]\n    dt=0.1\n    t = np.linspace(0,days,int(days/dt))\n    sigma, beta, gam = parms\n    for _ in t[1:]:\n        next_S = S[-1] - beta*S[-1]*I[-1]*dt\n        Epd.append(beta*S[-1]*I[-1]*dt)\n        next_E = E[-1] + (beta*S[-1]*I[-1] - sigma*E[-1])*dt\n        Ipd.append(sigma*E[-1]*dt)\n        next_I = I[-1] + (sigma*E[-1] - gam*I[-1])*dt\n        Rpd.append(gam*I[-1]*dt)\n        next_R = R[-1] + (gam*I[-1])*dt\n        S.append(next_S)\n        E.append(next_E)\n        I.append(next_I)\n        R.append(next_R)\n    return np.stack([S, E, I, R, Epd, Ipd, Rpd]).T\n\n\n\nLatent period \\(= T_{Latent} = \\frac{1}{\\sigma}\\)\nUsing the numerical model in part 2 and in order to see the distribution of E → I, we set the initial number of E to be the same as the population, and plot the number of E over time as below:\n\n\nCode\n# Define parameters\ndays = 30\nN = 10000\ninit = 0, N, 0, 0\nsigma = 1/5.2\nbeta = 0.5\ngam = 1/28.85\nparms = sigma, beta, gam\n\n# Plot simulation\nfig = go.Figure(data=[       \n    go.Scatter(name='E to I', x=np.linspace(0,days,days*10), y=100*(1-seir_model(init, parms, days).T[1]/N)), \n    go.Scatter(name='$\\\\text{Exponential distribution with} Scale = \\\\frac{1}{\\sigma}$', x=np.arange(days), y=100*expon.cdf(np.arange(days),loc=0,scale=1/sigma))\n])\n\nfig.update_layout(\n    title='Number of E moving to I over time when all population is exposed on day 0',\n    xaxis_title='Days',\n    yaxis_title='Percent of exposed having become infectious',\n    legend=dict(\n        x=0.6,\n        y=0,\n        traceorder=\"normal\",\n    )\n)\n\nfig\n\n\n\n                                                \n\n\nThe plot above confirms the numerical model from part 2 assumes people go from E → I according to the exponential distribution.\n\n\nInfectious period \\(= T_{Infectious} = \\frac{1}{\\gamma}\\)\nThe same discussion above applies for the time from I → R here.\nFrom the discussion above, we know the numerical model in part 2 approximates the time from I → R as an exponential distribution.\nLet’s verifiy this in the plot below:\n\n\nCode\n# Define parameters\ndays = 100\nN = 10000\ninit = 0, 0, N, 0\nsigma = 1/5.2   # 1/5 --&gt; 5 days on average to go from E --&gt; I\nbeta = 0.5\ngam = 1/28.85     # 1/11 --&gt; 11 days on average to go from I --&gt; R\nparms = sigma, beta, gam\n\n# Plot simulation\nfig = go.Figure(data=[       \n    go.Scatter(name='I to R', x=np.linspace(0,days,days*10), y=100*(1-seir_model(init, parms, days).T[2]/N)), \n    go.Scatter(name='$\\\\text{Exponential distribution with} Scale = \\\\frac{1}{\\gamma}$', x=np.arange(days), y=100*expon.cdf(np.arange(days),loc=0,scale=1/gam))\n    ])\n\nfig.update_layout(\n    title='Number of I moving to R over time when all population is infectious on day 0',\n    xaxis_title='Days',\n    yaxis_title='Percent of infectious having become recovered',\n    legend=dict(\n        x=0.6,\n        y=0,\n        traceorder=\"normal\",\n    )\n)\n\nfig\n\n\n\n                                                \n\n\nThe plot above confirms the numerical model from part 2 assumes people go from I → R according to the exponential distribution."
  },
  {
    "objectID": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#comparing-exponential-distribution-to-covid-19-data",
    "href": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#comparing-exponential-distribution-to-covid-19-data",
    "title": "Epidemic modeling - Part 3",
    "section": "Comparing exponential distribution to COVID-19 data",
    "text": "Comparing exponential distribution to COVID-19 data\nAs we have seen above, this deterministic model implies \\(T_{Latent}\\) and \\(T_{Infectious}\\) are exponentially distributed and we know the exponential distribution is uniquely characterized by its scale where: \\[scale = \\frac{1}{mean}\\]\n\nLatent period\nFor COVID-19, as we have seen in part 2 of the blog, research has shown the following for \\(T_{Latent}\\):\n\nmean = 5.2 days\nrange is [2,14] days\n95th percentile is 12.5 days\n\nAssuming an exponential distribution, however, we would obtain the following:\n\n\\(mean = \\frac{1}{scale} = 5.2\\ days\\)\n95th percentile would be 16 days\nAfter the first day in state E, 18% would move into the state I (the fastest in real-world data was 2 days so this is not possible)\n\nWhile we can adjust to scale to fit the real-world mean, the distribution does not match the real-world data.\n\n\nInfectious period\nSimilarly as above, for COVID-19 we have seen research has shown the following for \\(T_{Infectious}\\):\n\nmedian = 20 days\nrange is [8,37] days\n\nAssuming an exponential distribution, however, we would obtain the following:\n\n\\(mean = \\frac{median}{\\ln2} = \\frac{20}{\\ln2} = 28.85\\ days\\)\n95th percentile would be 87 days, while we’d likely want it to be around 37 days\nAfter the first day in state I, 18% would move into the state R (the fastest in real-world data was 8 days so this is not possible)\n\nWhile we can adjust to scale to fit the real-world mean, the distribution does not match the real-world data - and for a parameter that influences the overall simulation, it is pretty far off.\nLet’s see what distribution looks more likely."
  },
  {
    "objectID": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#finding-a-better-fit-gamma-or-weibull-distributions",
    "href": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#finding-a-better-fit-gamma-or-weibull-distributions",
    "title": "Epidemic modeling - Part 3",
    "section": "Finding a better fit: Gamma or Weibull distributions?",
    "text": "Finding a better fit: Gamma or Weibull distributions?\nWe have seen how different the actual COVID-19 \\(T_{Latent}\\) and \\(T_{Infectious}\\) were from the deterministic model using exponential distributions.\nHere we want to find a better distribution, and one that immediatly comes to mind is the Gamma distribution.\nAnother is the Weibull distribution.\n\nCharacterizing the Gamma distribution\nThe gamma distribution is characterized by its shape parameter \\(k\\) and its scale parameter \\(\\theta\\), where: \\[Mean = k~\\theta\\]\n\n\nCharacterizing the Weibull distribution\nSimilarly, the Weibull distribution is characterized by its shape parameter \\(k\\) and its scale parameter \\(\\theta\\), where: \\[Mean=\\lambda \\Gamma \\left(1+{\\frac {1}{k}}\\right)\\] And: \\[Median = \\lambda (\\ln 2)^{1/k}\\]\n\n\nGamma distributed latent period\nLet’s first find a Gamma distribution to match \\(T_{Latent}\\) data for COVID-19.\nThe mean is 5.2 days.\nThe range is [2,14] days and 95th percentile is 12.5 days, so we could translate this as follows:\n\n5th percentile = 2 days\n95th percentil = 12.5 days\n\n\\[Mean = k~\\theta\\] \\[\\leftrightarrow k~\\theta = 5.2\\] \\[\\leftrightarrow k = \\frac{5.2}{\\theta}\\]\nWe find the following parameters result in a pretty close distribution:\n\n\\(loc = 1.8\\)\n\\(k = 0.9\\)\n\\(\\theta = \\frac{5.2-loc}{k} = 3.\\dot{7}\\)\n\n\n\nCode\np=100000\n\ndays=30\n\nk=0.9\nlocg=1.8\ntheta=(5.2-locg)/k\n\nscalee=5.2\n\ndf = pd.DataFrame({\n    'Exponential': expon.rvs(scale=scalee,size=p),\n    'Gamma': gamma.rvs(k,loc=locg,scale=theta,size=p)\n    })\n\nt=PrettyTable(['Distribution', 'Mean', 'Median', '5th percentile', '95th percentile'])\nt.add_row(['Exponential', df.Exponential.mean(), df.Exponential.median(), df.Exponential.quantile(q=0.05), df.Exponential.quantile(q=0.95)])\nt.add_row(['Gamma', df.Gamma.mean(), df.Gamma.median(), df.Gamma.quantile(q=0.05), df.Gamma.quantile(q=0.95)])\nprint(t)\n\n\n+--------------+--------------------+--------------------+---------------------+--------------------+\n| Distribution |        Mean        |       Median       |    5th percentile   |  95th percentile   |\n+--------------+--------------------+--------------------+---------------------+--------------------+\n| Exponential  | 5.1759469433344005 | 3.5773832697380934 | 0.26174871624434964 | 15.496788295926194 |\n|    Gamma     | 5.173528721160346  | 4.046093033297662  |  1.9286735261748253 | 12.246827633416991 |\n+--------------+--------------------+--------------------+---------------------+--------------------+\n\n\n\n\nCode\nfig = go.Figure(data=[go.Table(\n    header=dict(values=list(df.describe(percentiles=[0.05, 0.95]).T.reset_index().columns),\n                fill_color='paleturquoise',\n                align='left'),\n    cells=dict(values=df.describe(percentiles=[0.05, 0.95]).T.reset_index().transpose().values.tolist(),\n               fill_color='lavender',\n               align='left'))\n])\n\nfig\n\n\n\n                                                \n\n\n\n\nCode\nfig = go.Figure(data=[       \n    go.Scatter(name='Gamma E --&gt; I', x=np.arange(days), y=gamma.cdf(np.arange(days), k, loc=locg, scale=theta), line={'color':'red'}),\n    go.Scatter(name='Expon E --&gt; I', x=np.arange(days), y=expon.cdf(np.arange(days), scale=scalee), line={'color':'blue'}),\n])\n\nfig.update_layout(\n    title={\n        'text':'Exponential vs. Gamma CDF',\n        'x':0.5,\n        'xanchor':'center'\n    },\n    xaxis_title='Days',\n    yaxis_title='Percent of exposed having become infectious',\n    legend=dict(\n        x=1,\n        y=0,\n        traceorder=\"reversed\",\n    )\n)\n\nfig\n\n\n\n                                                \n\n\n\n\nCode\np=10000\n\nk=0.9\nlocg=1.8\ntheta=(5.2-locg)/k\n\nscalee=5.2\n\ndf = pd.DataFrame({\n    'Exponential': expon.rvs(scale=scalee,size=p),\n    'Gamma': gamma.rvs(k,loc=locg,scale=theta,size=p)\n    })\n\nfig = px.histogram(df.stack().reset_index().rename(columns={\"level_1\": \"Distribution\"}), x=0, color=\"Distribution\", marginal='box')\nfig.update_layout(\n    title={\n        'text':'Exponential vs. Gamma distributions',\n        'x':0.5,\n        'xanchor':'center'\n    },\n    xaxis_title='Days',\n    yaxis_title='Count',\n    legend=dict(\n        x=1,\n        y=0,\n        traceorder=\"normal\",\n    )\n)\nfig\n\n\n\n                                                \n\n\n\n\nGamma or Weibull distributed infectious period\nWhile we used a Gamma distribution for \\(T_{Latent}\\) above, we do not have a mean for \\(T_{Infectious}\\) data for COVID-19. We can still try to find a Gamma distribution that matches but it may be a bit more difficult to do.\nWith the median however, we could use the Weibull distribution as described earlier.\n\\[Median = \\lambda (\\ln 2)^{1/k}\\] \\[\\leftrightarrow \\lambda = \\frac{Median}{(\\ln 2)^{1/k}}\\] \\[\\leftrightarrow \\lambda = \\frac{20}{(\\ln 2)^{1/k}}\\]\nThe range is [8,37] days so we could translate this as follows:\n\n5th percentile = 8 days\n95th percentil = 37 days\n\nWe find the following parameters result in a pretty close Gamma distribution:\n\n\\(loc = 3\\)\n\\(k = 4\\)\n\\(\\theta = 4.25\\)\n\nSimilarly, we find the following parameters result in a pretty close Weibull distribution: * \\(loc = 2\\) * \\(k = 2.3\\) * \\(\\lambda = \\frac{20-2}{(\\ln 2)^{1/k}} = 21.11\\)\n\n\nCode\np = 10000\n\ndays=80\n\nk=4\nlocg=3\ntheta=(20-locg)/k\n\nlocw=2\nwk = 2.3\nwl = (20-locw)/(math.log(2)**(1/wk))\n\nloce=0\nscale=28.85-loce\n\ndf = pd.DataFrame({\n    'Exponential': expon.rvs(loc=loce, scale=scale,size=p),\n    'Gamma': gamma.rvs(k,loc=locg,scale=theta,size=p),\n    'Weibull': weibull_min.rvs(wk, loc=locw, scale=wl,size=p)\n    })\n\nt=PrettyTable(['Distribution', 'Mean', 'Median', '5th percentile', '95th percentile'])\nt.add_row(['Exponential', df.Exponential.mean(), df.Exponential.median(), df.Exponential.quantile(q=0.05), df.Exponential.quantile(q=0.95)])\nt.add_row(['Gamma', df.Gamma.mean(), df.Gamma.median(), df.Gamma.quantile(q=0.05), df.Gamma.quantile(q=0.95)])\nt.add_row(['Weibull', df.Weibull.mean(), df.Weibull.median(), df.Weibull.quantile(q=0.05), df.Weibull.quantile(q=0.95)])\nprint(t)\n\nfig = go.Figure(data=[       \n    go.Scatter(name='Expon I --&gt; R', x=np.arange(days), y=expon.cdf(np.arange(days), loc=loce, scale=scale), line={'color':'blue'}),\n    go.Scatter(name='Gamma I --&gt; R', x=np.arange(days), y=gamma.cdf(np.arange(days), k, loc=locg, scale=theta), line={'color':'red'}),\n    go.Scatter(name='Weibull I --&gt; R', x=np.arange(days), y=weibull_min.cdf(np.arange(days), wk, loc=locw, scale=wl), line={'color':'green'})\n])\n\nfig.update_layout(\n    title={\n        'text':'Exponential vs. Gamma vs. Weibull CDF',\n        'x':0.5,\n        'xanchor':'center'\n    },\n    xaxis_title='Days',\n    yaxis_title='Percent of exposed having become infectious',\n    legend=dict(\n        x=1,\n        y=0,\n        traceorder=\"normal\",\n    )\n)\n\nfig\n\n\n+--------------+--------------------+--------------------+--------------------+-------------------+\n| Distribution |        Mean        |       Median       |   5th percentile   |  95th percentile  |\n+--------------+--------------------+--------------------+--------------------+-------------------+\n| Exponential  | 29.12075079684067  | 19.94157256238178  | 1.4659047789282902 | 89.47129269400085 |\n|    Gamma     |  20.0188121578611  | 18.510317480828895 | 8.758006502036336  | 35.92411486365206 |\n|   Weibull    | 20.612375502011442 | 19.87106323598139  |  7.72623443067804  | 36.05679172078921 |\n+--------------+--------------------+--------------------+--------------------+-------------------+\n\n\n\n                                                \n\n\n\n\nCode\nk=4\nlocg=3\ntheta=(20-locg)/k\n\nlocw=2\nwk = 2.3\nwl = (20-locw)/(math.log(2)**(1/wk))\n\nloce=0\nscalee=28.85-loce\n\np=10000\n\ndf = pd.DataFrame({\n    'Exponential': expon.rvs(loc=loce, scale=scalee,size=p),\n    'Gamma': gamma.rvs(k,loc=locg,scale=theta,size=p),\n    'Weibull': weibull_min.rvs(wk, loc=locw, scale=wl,size=p)\n    })\n\nfig = px.histogram(df.stack().reset_index().rename(columns={\"level_1\": \"Distribution\"}), x=0, color=\"Distribution\", marginal='box')\nfig.update_layout(\n    title={\n        'text':'Exponential vs. Gamma vs. Weibull distributions',\n        'x':0.5,\n        'xanchor':'center'\n    },\n    xaxis_title='Days',\n    yaxis_title='Count',\n    legend=dict(\n        x=1,\n        y=0,\n        traceorder=\"normal\",\n    )\n)\nfig"
  },
  {
    "objectID": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#discussion",
    "href": "posts/2020-03-25-proba-distrib/2020-03-25-proba-distrib.html#discussion",
    "title": "Epidemic modeling - Part 3",
    "section": "Discussion",
    "text": "Discussion\n\\(T_{Latent}\\) is nicely matched with a Gamma distribution.\n\\(T_{Infectious}\\) is nicely matched by a Weibull distribution.\nThe take away however is that the exponential distribution matches neither - and in the case of \\(T_{Infectious}\\) it is very far off.\nWe have seen in the previous posts that both of these periods have an impact on the peak proportion of infectious people and the duration of that peak.\nNaturally, we need to investigate further the impact of changing the distributions from exponential to Gamma and Weibull on the simulations.\nThis is done in the next blog post where I build a new model to be able to take into account the actual distributions."
  },
  {
    "objectID": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#motivation-for-write-up",
    "href": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 6",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 6th part of a multi-part series blog post on modeling in epidemiology.\nThe COVID-19 pandemic has brought a lot of attention to the study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on two key points.\nFollowing the first 5 parts of this blog series, we are left wondering what possible measures can be put in place to control the epidemic.\nThis 6th installment focuses on this and attempts to elucidate the subject."
  },
  {
    "objectID": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#why-do-we-need-control-measures-during-an-epidemic",
    "href": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#why-do-we-need-control-measures-during-an-epidemic",
    "title": "Epidemic modeling - Part 6",
    "section": "Why do we need control measures during an epidemic?",
    "text": "Why do we need control measures during an epidemic?\nIn the previous sections we have seen that without control measures in place i.e. when injecting an exposed person into the simulation, depending on the values of \\(\\beta\\) and \\(\\gamma\\), the virus will spread until it has infected everyone.\nThere are many reasons why this is bad with a virus as virulent as SARS-CoV-2:\n\nEven with a low Case Fatality Rate (CFR), the total death toll will be unacceptable\nThe strain on sanitary resources of peak sick people will lead to an increase in all-cause deaths\nThe strain on sanitary resources will lead to increased long-term morbidity\nMany economic implications\nMany many others…"
  },
  {
    "objectID": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#control-measures-the-basics",
    "href": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#control-measures-the-basics",
    "title": "Epidemic modeling - Part 6",
    "section": "Control measures: the basics",
    "text": "Control measures: the basics\nWhile the previous sections might have left us wondering what we can possibly do to control the pread of the epidemic, the evidence left from those studies in fact leave us with a lot of clues as to where to begin.\n\nOnly one way to stop an epidemic\nWe have seen there is only one way to stop an epidemic, and that is by having:\n\\[R \\leq 1\\] \\[\\leftrightarrow R_0~s(t) \\leq 1\\] \\[\\leftrightarrow \\frac{\\beta}{\\gamma}~s(t) \\leq 1\\]\n\n\nTwo methods to save lives\nFrom the equation above, we see an epidemic will either continue until herd immunity is reached:\n\\[s(t) \\leq \\frac{1}{R_0}\\] \\[\\leftrightarrow Immune(t) \\geq 1-\\frac{1}{R_0}\\]\nOr until measures are in place so that:\n\\[R_0 \\leq \\frac{1}{s(t)}\\]\nIn the worst case scenario where \\(s(t) = 1\\) (completely susceptible population), we need:\n\\[R_0 \\leq 1\\] \\[\\leftrightarrow \\beta \\leq \\gamma\\]\nFrom this results two main ideas of control:\n\nReaching herd immunity all while controlling peak infectious individuals to within hospital and sanitary resources so as to limit morbidity and mortality\nReducing \\(\\beta\\) to smaller than \\(\\gamma\\) to stop the epidemic even before herd immunity\n\nWhile the difference between the two is noted here, in practice they are effectively the same.\nOption 1 is the same as option 2, with the difference that in 1 we don’t quite have \\[R\\leq 1\\] and so the difference between the two results from different levels of imlementation.\n\n\nControl measures in practice\nWe have seen three things influence the total number of people that end up infected with the virus:\n\nProportion of Susceptible in population \\(s(t)\\)\nValue \\(\\beta\\)\nValue of \\(\\gamma\\) (\\(T_{Infectious}\\))\n\nWe have also seen that the peak of infectious individuals could be affected by:\n\nValue of \\(\\sigma\\) (\\(T_{Latent}\\))\n\nAnd indeed, reducing the peak of infectious at any point comes down to either:\n\nReducing the number of S:\nvaccination\nprophylactic treatment when potentially exposed\nReducing \\(\\beta = r * \\rho\\) by:\n\n\nreducing \\(r\\) i.e. reducing the average number of contacts a person has per day:\n\n\nlockdown measures\nwork from home\nclosing places where people gather (restaurants, bars, places of worship, etc)\n\n\nreducing \\(\\rho\\) - reducing the pobability of transmitting infection from an infectious to a susceptible via:\n\n\nphysical distancing\nhygiene measures\nwearing personal protective equipment (PPE i.e. masks, gloves, etc)\nReducing \\(\\gamma\\) by:\nIsolation of the sick (mass testing of symptomatic and immediate isolation of positive cases)\nContact-tracing: tracing and quarantining all contacts from infectious people as to quarantine potential exposed before they become infectious\nChemotherapy: treatment to shorten duration of sickness and infectious period\nIncreasing \\(\\sigma\\) by:\nprophylactic treatment when potentially exposed\n\nAll these are the same requirements to reduce \\(R \\leq 1\\).\nLet’s try to quantify the impact of each measure below.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\nfrom numpy.random import default_rng\nrng = default_rng()\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\n\n\n\n\n\n\nCode\n# Need this new function for model below:\ndef make_df(p,num_E, num_I, num_R):\n  df = pd.DataFrame(np.full((p,1), 'S').T[0], columns=['State'])\n  df['Day'] = 0\n  tochange=df.loc[rng.choice(p, size=num_E+num_I+num_R, replace=False),'State'].index\n  df.loc[tochange[0:num_E],'State'] = 'E'\n  df.loc[tochange[num_E:num_I+num_E],'State'] = 'I'\n  df.loc[tochange[num_E+num_I:num_E+num_I+num_R],'State'] = 'R'\n  return df\n\n\n\n\nCode\n# regular Stoachastic SEIR model below:\ndef seir_model_stoch_ctrl(beta, p, num_E, num_I, num_R, days, isolation, iso_n, contact_tracing, lockdown):\n\n    # Initialize population dataframe with data given by user\n    df = make_df(p,num_E, num_I, num_R)\n    \n    # This variable is used to track daily value of beta\n    xxbeta=np.array([],dtype=float)\n\n    # Initialize the arrays to return\n    # Below are numbers of S, E, I, R total\n    S=np.array([],dtype=int)\n    E=np.array([],dtype=int)\n    I=np.array([],dtype=int)\n    R=np.array([],dtype=int)\n    # Below are the daily additions in S, E, I, R\n    Spd=np.array([],dtype=int)\n    Epd=np.array([],dtype=int)\n    Ipd=np.array([],dtype=int)\n    Rpd=np.array([],dtype=int)\n\n    b=beta\n    beta2=b/10\n    beta3=b/10\n\n    lockdown_date=0\n    \n    # Stochastic model so use random values to decide on progression\n    rand = np.random.random(size=(p,days))\n\n    # Depending if you want exponential or gamma distribution for sigma\n    EtoI = gamma.rvs(1.8,loc=0.9,scale=(5.2-1.8)/0.9,size=p)\n\n    # Depending if you want exponential or gamma distribution for gamma and if you have isolation or not\n    # Uses distributiosn found on blog part 3\n    if isolation is True:\n      ItoR = iso_n*np.ones(p)\n    else:\n      ItoR = weibull_min.rvs(2.3, loc=2, scale=20.11, size=p)   \n\n\n    # Iterate over every day the simulation is run\n    for j in range(0,days):\n\n        # Record daily beta values\n        xxbeta=np.append(xxbeta, b[j])\n\n        # First we get the index of the individuals that will change state today:\n\n        # Random number tells you which 'S' have been exposed on this day \n        StoE_index = df.loc[(df.State == 'S') & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/p)].index\n\n        # For each row, if a person has been a certain number of days in E, they will go to I\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        EtoI_index = df.loc[(df.State == 'E') & (j-df.Day &gt;= EtoI)].index\n        \n        # Similaraly as above\n        # For each row, if a person has been a certain number of days in I, they will go to R\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        ItoR_index = df.loc[(df.State == 'I') & (j-df.Day &gt;= ItoR)].index\n\n        # Use indexes collected above to populate per day values\n        Epd = np.append(Epd,len(StoE_index))\n        Ipd = np.append(Ipd,len(EtoI_index))\n        Rpd = np.append(Rpd,len(ItoR_index))\n\n        # Append the S, E, I, and R arrays\n        S=np.append(S,len(np.where(df.State=='S')[0]))\n        E=np.append(E,len(np.where(df.State=='E')[0]))\n        I=np.append(I,len(np.where(df.State=='I')[0]))\n        R=np.append(R,len(np.where(df.State=='R')[0]))\n\n        # Now we use the indexes collected above randomly to change the actual population dataframe to the new states\n        df.iloc[ItoR_index] = ['R', j]\n        df.iloc[EtoI_index] = ['I', j]\n        df.iloc[StoE_index] = ['E', j]\n\n        # Code below for control measures to reduce beta values\n        if lockdown is True:\n          if ((I[-1] &gt; 100) & (Ipd[-1] &gt; 39)):\n            if lockdown_date == 0:\n              lockdown_date = j+1\n            b = beta2\n          elif ((I[-1] &gt; 100) & (Ipd[-1] &lt; 40)): \n            b = beta3\n        \n    Epd[0]+=num_E\n    Ipd[0]+=num_I\n    Rpd[0]+=num_R\n\n    return S,E,I,R, Epd, Ipd, Rpd, xxbeta, lockdown_date"
  },
  {
    "objectID": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#reducing-the-proportion-of-susceptible-in-the-population",
    "href": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#reducing-the-proportion-of-susceptible-in-the-population",
    "title": "Epidemic modeling - Part 6",
    "section": "Reducing the proportion of Susceptible in the population",
    "text": "Reducing the proportion of Susceptible in the population\nAs we have seen, reducing the proportion of susceptible in the population helps reduce the impact of the epidemic.\nIn the first blog post of the series, we derived the threshold for herd immunity as being:\n\\[1-\\frac{1}{R_0}\\]\nIn our simulations we have:\n\\[R_0 = \\frac{\\beta}{\\gamma} = \\frac{0.5}{\\frac{1}{20.62}} = 10.31\\]\nAnd so, the herd immunity threshold in our simulation should be:\n\\[HIT = \\frac{9.31}{10.31}~100\\% = 90.3\\%\\]\nLet’s run the model with the initial condition that 92% are in the R state already.\n\n\nCode\n# Define parameters for stochastic model\ndays = 300\np = 10000\nnum_E = 1\nnum_I = 0\n\n# Run 2 simulations, one above HIT, and one below:\nnum_R1 = 8000\nnum_R2 = 9200\nbeta_stoch = 0.5*np.ones(days)\niso_n = 0\n\n# Run 4 stochastic simulations, 2 with exponential sigma, 2 with gamma sigmalation, iso_n, contact_tracing, lockdown\nresults_stoch0 = seir_model_stoch_ctrl(beta_stoch, p, num_E, num_I, num_R1, days, isolation=False, iso_n=iso_n, contact_tracing=False, lockdown=False)\nresults_stoch1 = seir_model_stoch_ctrl(beta_stoch, p, num_E, num_I, num_R2, days, isolation=False, iso_n=iso_n, contact_tracing=False, lockdown=False)\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='I_below_HIT', x=np.arange(len(results_stoch0[0])), y=results_stoch0[2]/p),\n    go.Scatter(name='I_above_HIT', x=np.arange(len(results_stoch1[0])), y=results_stoch1[2]/p),\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of herd immunity on SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#reducing-beta",
    "href": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#reducing-beta",
    "title": "Epidemic modeling - Part 6",
    "section": "Reducing \\(\\beta\\)",
    "text": "Reducing \\(\\beta\\)\nSee blog post 2 for effect of \\(\\beta\\) on the SEIR model."
  },
  {
    "objectID": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#reducing-gamma",
    "href": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#reducing-gamma",
    "title": "Epidemic modeling - Part 6",
    "section": "Reducing \\(\\gamma\\)",
    "text": "Reducing \\(\\gamma\\)\n\nIsolating positive tests\nSay you isolate positive tests and are able to test everyone.\nWhat if tests are positive \\(n\\) days after people are infectious ?\nYou can isolate people after \\(n\\) days and this effectively reduces \\(T_{Infectious}\\) to \\(n\\) days.\nLet’s plot the total infectious individuals with:\n\nn = 10 days\nn = 7 days\nn = 5 days\nn = 2 days\n\n\n\nCode\n# Define parameters for stochastic model\ndays = 200\np = 10000\nnum_E = 1\nnum_I = 0\nnum_R = 0\nbeta_stoch = 0.5*np.ones(days)\n\n# Isolate after iso_n days\niso_n1 = 10 # Test and isolate all infectious after 10 days\niso_n2 = 7\niso_n3 = 5\niso_n4 = 2\n\n# Run 4 stochastic simulations, 2 with exponential sigma, 2 with gamma sigmalation, iso_n, contact_tracing, lockdown\nresults_stoch0 = seir_model_stoch_ctrl(beta_stoch, p, num_E, num_I, num_R, days, isolation=False, iso_n=iso_n, contact_tracing=False, lockdown=False)\nresults_stoch1 = seir_model_stoch_ctrl(beta_stoch, p, num_E, num_I, num_R, days, isolation=True, iso_n=iso_n1, contact_tracing=False, lockdown=False)\nresults_stoch2 = seir_model_stoch_ctrl(beta_stoch, p, num_E, num_I, num_R, days, isolation=True, iso_n=iso_n2, contact_tracing=False, lockdown=False)\nresults_stoch3 = seir_model_stoch_ctrl(beta_stoch, p, num_E, num_I, num_R, days, isolation=True, iso_n=iso_n3, contact_tracing=False, lockdown=False)\nresults_stoch4 = seir_model_stoch_ctrl(beta_stoch, p, num_E, num_I, num_R, days, isolation=True, iso_n=iso_n4, contact_tracing=False, lockdown=False)\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='I_no_isolation', x=np.arange(len(results_stoch0[0])), y=results_stoch0[2]/p),\n    go.Scatter(name='I_iso10', x=np.arange(len(results_stoch1[0])), y=results_stoch1[2]/p),\n    go.Scatter(name='I_iso7', x=np.arange(len(results_stoch2[0])), y=results_stoch2[2]/p),\n    go.Scatter(name='I_iso5', x=np.arange(len(results_stoch3[0])), y=results_stoch3[2]/p),\n    go.Scatter(name='I_iso2', x=np.arange(len(results_stoch4[0])), y=results_stoch4[2]/p),\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':'Effect of early testing and isolation on SEIR model',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nClearly, early testing and isolation of cases reduces transmission and this the peak of infectious individuals. The faster we do this the better.\nIf we catch infectious individuals early enough, we can completely control the epidemic (see I_iso_2 above)."
  },
  {
    "objectID": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#discussion",
    "href": "posts/2020-04-02-control-measures/2020-04-02-control-measures.html#discussion",
    "title": "Epidemic modeling - Part 6",
    "section": "Discussion",
    "text": "Discussion\nThis was a quick introduction to the basics of control measures and their impact on the SEIR model.\nWhile there are many different possible approaches, the accumulation of the different solutions is the way to achieve control over an epidemic.\nMaybe I will make an interactive app to see the effect of each effect."
  },
  {
    "objectID": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#motivation-for-write-up",
    "href": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#motivation-for-write-up",
    "title": "Testing - what to be aware of",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThe real-world motivation for this write-up can be found under Story Time section, but I first wanted to give a bit of theoretical background here.\nThe importance of testing has been greatly talked about these last few weeks/months with the emergence of the COVID-19 pandemic with numerous articles being published, all underlining the importance of testing. The part emphasized is the fact that early testing allows for quick isolation of sick individuals and tracing of their potential contacts, and thus limiting the potential for spread.\nThe kind of test for this are called virologic testing and test directly for the presence of virus in an individual (active infection). This is done with Nucleic Acid Tests, or NAT, usually after amplification of the very small amount of genetic material present via Polymerase Chain Reaction. Results are available within hours or days and require diagnostic machinery and specialists.\nKnowing who has been infected is also important as it could allow already recovered patients (who are thought to gain immunity from COVID-19) to return safely to work and live basically normally. Tests that check for past infections exist, and are called serology or antibody tests. They check for specific antibodies that match those deveopped during an immune response response against SARS-CoV-2.\nThis is all good in theory, but with a disease that can cause such serious conditions as COVID-19 can, we need to be sure a positive test means for certain that person is now immmune, or we risk allowing individuals with false positives to return to normal when they should not, and continue the damaging spread of the disease.\nThe aim of this short right-up is to clear up some misconceptions around testing protocols, discuss the importance of false positives, false negatives, and its importance to guiding public health policies. The idea is basically to answer the following questions:\n\nHow many tests should return positive for a person to be, say 95% or 99% person sure he is now immune?\nWhat if a different test is negative?"
  },
  {
    "objectID": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#specificity-sensitivity-false-positives-false-negatives",
    "href": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#specificity-sensitivity-false-positives-false-negatives",
    "title": "Testing - what to be aware of",
    "section": "Specificity, Sensitivity, False positives, False negatives?",
    "text": "Specificity, Sensitivity, False positives, False negatives?\nAs briefly explained above, neither virological and serological tests are infallible. False positives i.e. healthy individuals with a positive test, and false negatives i.e. infected indiviuals with negative tests, can, and do happen.\nThere are numerous reasons how and why this can happen, but that is not the point of this write-up. Here, we acknowledge the fact non-perfect tests are a reality and establish testing protocol to deal with that fact.\nThankfully, before being shipped out, the various laboratories test their tests. They are able to characterize them rather precisely and give an indiction of how useful they may be with two important values:\n\nSpecificity\nSensitivity\n\n\nSpecificity\nSpecificity is the true negative rate - i.e. the percentage of healthy people correctly identified as such (for antibody testing, it is the percentage of people not having antibodies correctly identified as such).\nIn other words, if a test was used on 100 people who do not have antibodies, the number of people correctly identified as not hvaing antibodies is the specificity.\nA perfect test with 100% specificity, means there are no false positives. This has major implications in the current context of COVID-19 pandemic as having an anitbody test with 100% specificity would allow immune people to know so for certain (as long as research showed antibodies gave immunity).\nMathematically, we pose specificity as follows:\n\\[Specificity = \\frac{True\\ negatives}{True\\ negatives + False\\ posiives}\\]\n\n\nSensitivity\nSensitivity is the true positive rate - i.e. the percentage of infected people correctly identified as such (for antibody tests, it is the percentage of people having antibodies correctly identified as such).\nIn other words, if an antibody test was used on 100 people with antibodies, the number of people correctly identified as having anitbodies is the sensitivity.\nA perfect test with 100% sensitivity, means there are no false negatives.\nMathematically, we pose specificity as follows:\n\\[Sensitivity = \\frac{True\\ positives}{True\\ positives + False\\ negatives}\\]\n\n\nPrevalence\nPrevalence is simply the proportion of a population that has a certain characteistic. In the current context of antibody testing, the prevalence will be defined as the proportion of people who have antibody conferring immunity to COVID-19 (i.e. the proportion that has had the disease).\n\\[Prevalence = \\frac{\\#\\ People\\ with\\ antibodies}{Total\\ number\\ of\\ people}\\]\nWhere \\(Total\\ number\\ of\\ people\\) is simply \\(\\#\\ People\\ with\\ antibodies + \\# People\\ without\\ antibodies\\)"
  },
  {
    "objectID": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#story-time---part-1",
    "href": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#story-time---part-1",
    "title": "Testing - what to be aware of",
    "section": "Story time - Part 1",
    "text": "Story time - Part 1\nSpecificity, sensitivity, prevalence, false negatives, false positives.. This is all good, but it can be a bit abstract outside of a specific testing context.\nLet’s use the current COVID-19 pandemic as an example.\nAntibody tests are finally becoming available to the general population, and you want to know if you’ve had the disease (developped antibodies against it).\n\nNow let’s say you had influenza like symptoms back in January or February, would you expect a positive or negative result on the test?\nWhat if you haven’t been sick but want to check out of curiosity, what result would you expect?\nIf it does come back positive, how certain would you be that you actually have those antibodies and it wasn’t a false positive?\nYou decide to use a second test to make sure, again it comes positive. Now how certain are you that you have antibodies?\nOut of extreme precaution you decide to try a test from another laboratory (different specificity and sensitivity), and this time the test comes back negative. It’s become a bit more complex to evaluate your situation now.\nSo how about another test from this second laboratory? Again, negative.. Two positives, two negatives - what can you make of this information?\n\nHowever far fetched this scenario may seem, it is exactly what happened to this Florida physician:\n\ntwitter: https://twitter.com/HandtevyMD/status/1245832946612711424\n\nThere are two questions that come out of this story:\n\nAfter those 4 tests, what is the probability that Dr. Antevy has those antibodies - or more generally, can we calculate the probability of someone having antibodies given their test results?\nWhat should be the threshold of such a probability to minimize the risk of someone without antibodies going out in nature thinking he does ? (obviously if someone has 10 positive tests in a row, it seems sure enough that person has antibodies) This pushes for the need of rigorous testing protocol."
  },
  {
    "objectID": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#calculating-probabilites-given-test-results",
    "href": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#calculating-probabilites-given-test-results",
    "title": "Testing - what to be aware of",
    "section": "Calculating probabilites given test results",
    "text": "Calculating probabilites given test results\nClearly, our objective is to calculate the probability that a person has antibodies, or:\n\\[P(seropositive)\\]\n\nConditional probabilities\nBaye’s theorem describes probabilities when given evidence.\nSay a person has had some COVID-19 symptoms (dry cough, fever, loss of smell, slight fever) a few weeks ago. He might say there is a 75% chance that he had contracted COVID-19, and 25% chance it was another disease. In this case:\n\\[P(seropositive) = 0.75\\]\nNow this person goes to get an antibody test. What is the probability he is seropositive given a positive or negative result? Baye’s theorem allows us to write it as follows:\n\\[P(seropositive\\ |\\ positive\\ test) = \\frac{P(positive\\ test\\ |\\ seropositive)\\ *\\ P(seropositive)}{P(positive\\ test)}\\]\nand\n\\[P(seropositive\\ |\\ negative\\ test) = \\frac{P(negative\\ test\\ |\\ seropositive)\\ *\\ P(seropositive)}{P(negative\\ test)}\\]\nNote:\n\n\\(P(seropositive)\\) is called the prior.\n\\(P(seropositive\\ |\\ positive\\ test)\\) and \\(P(seropositive\\ |\\ negative\\ test)\\) are called the posterior.\n\n\n\n\\(P(Positive\\ test)\\)\nLet’s have a look at the probability of getting a positive test - there are 2 ways to get a positive result :\n\nA false positive\nA true positive\n\n\\[P(False\\ positive) = P(Positive\\ test\\ |\\ seronegative)*P(seronegative)\\]\nAnd\n\\[P(True\\ positive) = P(Positive\\ test\\ |\\ seropositive)*P(seropositive)\\]\nSo:\n\\[P(Positive\\ test) = P(Positive\\ test\\ |\\ seropositive)*P(seropositive) + P(Positive\\ test\\ |\\ seronegative)*P(seronegative)\\]\n\n\nSensitivity and Specificity revisited\nEarlier we saw:\n\\[Sensitivity = \\frac{True\\ positives}{True\\ positives + False\\ negatives}\\]\nAnd that\n\\[Specificity = \\frac{True\\ negatives}{True\\ negatives + False\\ positives}\\]\nBut we can rewrite these equations as follows:\n\\[Sensitivity = P(Positive\\ test\\ |\\ seropositive)\\]\nAnd\n\\[Specificity = P(Negative\\ test\\ |\\ seronegative) = 1-P(Positive\\ test\\ |\\ seronegative)\\]\n\n\nRe-writing the posterior probability\nUsing Baye’s rule and the calculations above we can re-write the posterior equations as follows:\n\\[P(seropositive\\ |\\ Positive\\ test) = \\frac{Sensitivity*P(seropositive)}{Sensitivity*P(seropositive)+ (1-Specificity)*(1-P(seropositive))}\\]\nAnd:\n\\[P(seronegative\\ |\\ Negative\\ test) = \\frac{Specificity*(1-P(seropositive))}{Specificity*(1-P(seropositive))+(1-Sensitivity)*P(seropositive)}\\]\n\n\nThe role of prevalence in these calculations\nThe equations above describe the probability for an individual given a test result and their prior probability. This prior probability can be estimated given presence or not of symptoms, contact with other infected individuals, location, other diagnostics, etc…\nHowever, on a population level, if we were to test a random individual, this prior becomes the prevalence and for a random individual, the equations become:\n\\[P(seropositive\\ |\\ Positive\\ test) = \\frac{Sensitivity*Prevalence}{Sensitivity*Prevalence+(1-Specificity)*(1-Prevalence)}\\]\nAnd:\n\\[P(seronegative\\ |\\ Negative\\ test) = \\frac{Specificity*(1-Prevalence)}{Specificity*(1-Prevalence)+(1-Sensitivity)*Prevalence}\\]"
  },
  {
    "objectID": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#serology-testing-simulation",
    "href": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#serology-testing-simulation",
    "title": "Testing - what to be aware of",
    "section": "Serology testing simulation",
    "text": "Serology testing simulation\nLet’s see what these equations look like in practice.\n\n\nCode\nimport numpy as np\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\n\n\n\n\n\n# Let's write a function to output the posterior probability given prior, test result, and test characteristics (sensitivity and specificity)\ndef Pposterior(Pprior, test_res, Sn, Sp):\n  if test_res:\n    return ((Sn * Pprior) / (Sn * Pprior + (1-Sp) * (1-Pprior)))\n  else:\n    return (1-((Sp * (1-Pprior))/(1-(Sn * Pprior + (1-Sp) * (1-Pprior)))))\n\nSay we have an antibody test with 90% sensitivity and 90% specificity - meaning we have 90% true positives and 90% true negatives, we obtain a graph as below:\n\n\nCode\n# Below is the prior probability of being infected:\nnum=10000\nPprior = np.linspace((1/num),(num-1)/num,num=num)\n\n# Graph the results\nfig = go.Figure(data=[\n    go.Scatter(name='Test negative', x=100*Pprior, y=100*Pposterior(Pprior, False, 0.9, 0.9), line_color=\"green\"),\n    go.Scatter(name='Test positive', x=100*Pprior, y=100*Pposterior(Pprior, True, 0.9, 0.9), line_color=\"red\"),\n    go.Scatter(name='No test', x=100*Pprior, y=100*Pprior, line_color=\"blue\")\n])\n\nfig.update_layout(\n    xaxis_title = 'Prior probability of being infected',\n    yaxis_title = 'Posterior probability of being infected given test result&lt;br&gt;Specificity=90.0&lt;br&gt;Sensitivity=90.0'\n)\n\nfig.show()\n\n\n\n                                                \n\n\nIf you hover the mouse over the lines you can see the exact numbers.\nAs you can see, a positive or negative test does give more information than no test, but it doesn’t quite give you certainty."
  },
  {
    "objectID": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#story-time---part-2",
    "href": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#story-time---part-2",
    "title": "Testing - what to be aware of",
    "section": "Story time - Part 2",
    "text": "Story time - Part 2\nLet’s circle back to our Dr. Antevy with his two positive tests and the two negative tests.\nPrior to any tests, he was about 50% certain of having contracted COVID-19 based on his assesment of his symptoms, location, contact with other people, etc..\nLet’s go through his test results to see what his posterior probability of having antibodies is.\n\n\nCode\n# Let's make a new function for multiple tests in a row\n\ndef PposteriorM(Pprior, test_res):\n  x = Pprior\n  for tr, sn, sp in test_res:\n    if tr == 1:\n      x = (sn * x) / (sn * x + (1-sp) * (1-x))\n    elif tr == 0:\n      x = (1-((sp * (1-x))/(1-(sn * x + (1-sp) * (1-x)))))\n  return x\n\n\nLet’s say these are the characteristics of the tests he used:\n\nTest 1 and 2:\nSpecificity = 0.90\nSensitivity = 0.99\nTest 3 and 4:\nSpecificity = 0.97\nSensitivity = 0.95\n\nSo a highly sensitive first test followed by a rather good allround test, a bit more specific than the first.\n\n\nCode\n# Below is the prior probability of being infected:\nnum=10000\nPprior = np.linspace((1/num),(num-1)/num,num=num)\n\n# Test characteristics\ntest_results = [(1, 0.99, 0.90),(1, 0.99, 0.90),(0,0.95,0.97),(0,0.95,0.97)]\n\n# Graph the results\nfig = go.Figure(data=[\n    go.Scatter(name='1 - 1st positive test', x=100*Pprior, y=100*PposteriorM(Pprior, [test_results[0]])),\n    go.Scatter(name='2 - 2nd positive test', x=100*Pprior, y=100*PposteriorM(Pprior, test_results[0:2])),\n    go.Scatter(name='3 - 1st negative test', x=100*Pprior, y=100*PposteriorM(Pprior, test_results[0:3])),\n    go.Scatter(name='4 - 2nd negative test', x=100*Pprior, y=100*PposteriorM(Pprior, test_results[0:4]))    \n])\n\nfig.update_layout(\n    xaxis_title = 'Prior probability of being infected',\n    yaxis_title = 'Posterior probability of being infected given test results'\n)\n\nfig.show()\n\n\n\n                                                \n\n\nSo let’s go through step-by-step:\n\nBefore any test, he was about 50% sure he contracted COVID-19\nAfter the 1st positive test, this goes up to 90.8% sure\nAfter the 2nd positive test, up to 99.0% sure\nBut the 1st negative test drops it back to 83.5%\nAnd the 2nd negative all the way down to 20.7%\n\nWhat if this was done on a random person in France for example, and all 4 tests were positive.\nThen the prior would be the prevalence in France (0.2%) instead of 50%, and the step by step would be as follows:\n\nBefore any test, about 0.20%\nAfter 1st positive: still only 1.9% chance of being seropositive\n\nAfter 2nd positive test: only 16.4% chance of seropositive\nAfter 3rd positive: 86%\nAnd after 4th positive test 99.5%\n\nSo it took about 4 positive tests for a random person in France to become confident enough to be seropositive."
  },
  {
    "objectID": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#discussion",
    "href": "posts/2020-04-12-on-testing/2020-04-12-on-testing.html#discussion",
    "title": "Testing - what to be aware of",
    "section": "Discussion",
    "text": "Discussion\nThe results above strongly underline the need for clear testing protocols and clear understanding of the interpretation of test results.\nWith a disease that can be so devastating as COVID-19, a few things should be kept in mind:\n\nA high treshold should be used to hedge the risk a false positive\nMultiple tests should be taken\nMultiple tests with different characteristics (ideally at least one with high sensitivity, and one with high specificity)"
  },
  {
    "objectID": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#motivation-for-write-up",
    "href": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 4",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 4th part of a multi-part series blog post on modeling in epidemiology.\nThe COVID-19 pandemic has brought a lot of attention to study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on two key points.\nAfter introducing the concepts of compartmentalization and disease dynamics in the first blog post, the second part looked at a deterministic numerical solution for the SEIR model discussed, and the effects of the parameters \\(\\beta\\), \\(\\sigma\\), and \\(\\gamma\\) in parts 1 and 2.\nPart 3 made the argument that most models ignore individual-level disease dynamics in favor of averaging population-level \\(\\sigma\\) and \\(\\gamma\\) parameters and showed some big discrepancies between actual COVID-19 probability distributions for those parameters and those used in research.\nThis 4th part is where I build a numerical SEIR model that takes into account these probability distributions in order to tweak the model as close to COVID-19 data as possible."
  },
  {
    "objectID": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#building-a-stochastic-model",
    "href": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#building-a-stochastic-model",
    "title": "Epidemic modeling - Part 4",
    "section": "Building a stochastic model",
    "text": "Building a stochastic model\nAs opposed to the deterministic model from Part 2, this model is going to focus on individual level disease dynamics to model the disease propagation.\nThe basic idea of this model is to have a dataframe with the number of rows equal to the population size (each individual is a row) and two columns:\n\nState column to describe the state of each individual (S, E, I, or R)\nDay column to save the day of transition of the individual into that state\n\nHowever, the population-level rates of transmission still apply here i.e. a person goes from S → E following three points:\n\nthe number of contacts the person has per unit time (given by \\(r\\))\nthe chance a given contact is with an I - infectious individual (the higher thenumber of I, the higher the chance)\nthe chance of an S contracting the disease from a contact with an I (given by \\(\\rho\\))\n\nThis is done stochastically.\nOnce a person becomes E, their progression is unique to them. This progression is calculated in advance for computational reason, but it allows to use the time ditributions we want.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport math\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\nfrom numpy.random import default_rng\nrng = default_rng()\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\n# Let's build a numerical solution\ndef seir_model(init, parms, days):\n    S_0, E_0, I_0, R_0 = init\n    Epd, Ipd, Rpd = [0], [0], [0]\n    S, E, I, R = [S_0], [E_0], [I_0], [R_0]\n    dt=0.1\n    t = np.linspace(0,days,int(days/dt))\n    sigma, beta, gam = parms\n    for _ in t[1:]:\n        next_S = S[-1] - beta*S[-1]*I[-1]*dt\n        Epd.append(beta*S[-1]*I[-1]*dt)\n        next_E = E[-1] + (beta*S[-1]*I[-1] - sigma*E[-1])*dt\n        Ipd.append(sigma*E[-1]*dt)\n        next_I = I[-1] + (sigma*E[-1] - gam*I[-1])*dt\n        Rpd.append(gam*I[-1]*dt)\n        next_R = R[-1] + (gam*I[-1])*dt\n        S.append(next_S)\n        E.append(next_E)\n        I.append(next_I)\n        R.append(next_R)\n    return np.stack([S, E, I, R, Epd, Ipd, Rpd]).T\n\n\n\n\n\n\nCreating the initial population dataframe\nBelow is a function to create the initial population dataframe: * \\(p\\) is the population number * \\(num_E\\) is the number of people exposed on day 0 * \\(num_I\\) is the number of infectious on day 0 * \\(num_R\\) is the number of people recovered on day 0\n\n\nCode\n# Need this new function for model below:\ndef make_df(p,num_E, num_I, num_R):\n  df = pd.DataFrame(np.full((p,1), 'S').T[0], columns=['State'])\n  df['Day'] = 0\n  tochange=df.loc[rng.choice(p, size=num_E+num_I+num_R, replace=False),'State'].index\n  df.loc[tochange[0:num_E],'State'] = 'E'\n  df.loc[tochange[num_E:num_I+num_E],'State'] = 'I'\n  df.loc[tochange[num_E+num_I:num_E+num_I+num_R],'State'] = 'R'\n  return df\n\n\n\n\nBuilding the model\n\n\nCode\ndef seir_model_stoch(beta, p, num_E, num_I, num_R, days, T_Latent, T_Infectious):\n\n    # Initialize population dataframe with data given by user\n    df = make_df(p,num_E, num_I, num_R)\n    \n    # This variable is used to track daily value of beta if it varies over time\n    xxbeta=np.array([],dtype=float)\n\n    # Initialize the arrays to return\n    # Below are numbers of S, E, I, R total\n    S=np.array([],dtype=int)\n    E=np.array([],dtype=int)\n    I=np.array([],dtype=int)\n    R=np.array([],dtype=int)\n    # Below are the daily additions in S, E, I, R\n    Spd=np.array([],dtype=int)\n    Epd=np.array([],dtype=int)\n    Ipd=np.array([],dtype=int)\n    Rpd=np.array([],dtype=int)\n\n    b=beta\n    \n    # Stochastic model so use random values to decide on progression\n    rand = np.random.random(size=(p,days))\n\n    # Depending if you want exponential or gamma distribution for T_Latent\n    if T_Latent == 'expon':\n      EtoI = expon.rvs(loc=0,scale=5.2,size=p)\n    else:\n      EtoI = gamma.rvs(1.8,loc=0.9,scale=(5.2-1.8)/0.9,size=p)\n\n    # Depending if you want exponential, gamma, or Weibull distribution for T_Infectious\n    # Uses distributions found on blog part 3\n    if T_Infectious == 'expon':\n      ItoR = expon.rvs(loc=0,scale=28.85,size=p)\n    elif T_Infectious == 'gamma':\n      ItoR = gamma.rvs(4,loc=3,scale=4.25,size=p)    \n    else:\n      ItoR = weibull_min.rvs(2.3, loc=2, scale=20.11, size=p)\n\n    # Iterate over every day the simulation is run\n    for j in range(0,days-1):\n\n        # Record daily beta values\n        xxbeta=np.append(beta, b)\n\n        # First we get the index of the individuals that will change state today:\n\n        # Random number tells you which 'S' have been exposed on this day \n        StoE_index = df.loc[(df.State == 'S') & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/p)].index\n\n        # For each row, if a person has been a certain number of days in E, they will go to I\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        EtoI_index = df.loc[(df.State == 'E') & (j-df.Day &gt;= EtoI)].index\n        \n        # Similaraly as above\n        # For each row, if a person has been a certain number of days in I, they will go to R\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        ItoR_index = df.loc[(df.State == 'I') & (j-df.Day &gt;= ItoR)].index\n\n        # Use indexes collected above to populate per day values\n        Epd = np.append(Epd,len(StoE_index))\n        Ipd = np.append(Ipd,len(EtoI_index))\n        Rpd = np.append(Rpd,len(ItoR_index))\n\n        # Now we use the indexes collected above randomly to change the actual population dataframe to the new states\n        df.iloc[ItoR_index] = ['R', j]\n        df.iloc[EtoI_index] = ['I', j]\n        df.iloc[StoE_index] = ['E', j]\n        \n        # Append the S, E, I, and R arrays\n        S=np.append(S,len(np.where(df.State=='S')[0]))\n        E=np.append(E,len(np.where(df.State=='E')[0]))\n        I=np.append(I,len(np.where(df.State=='I')[0]))\n        R=np.append(R,len(np.where(df.State=='R')[0]))\n\n        # Code below for control measures to reduce beta values\n#        if ((I[-1] &gt; 1000) & (Ipd[-1] &gt; 399)): \n#            b = beta2\n#        elif ((I[-1] &gt; 1000) & (Ipd[-1] &lt; 400)): \n#            b = beta3\n                \n    Epd[0]+=num_E\n    Ipd[0]+=num_I\n    Rpd[0]+=num_R\n\n    return S,E,I,R, Epd, Ipd, Rpd, xxbeta\n\n\n\nSanity check\nLet’s first make sure the stochastic model above gives similar result to the deterministic model previously used in part 2 if we use an exponential distribution for \\(T_{Latent}\\) and \\(T_{Infectious}\\).\n\nE → I\nSo let’s first set all individuals to exposed on day 0 and see the progression to I with exponential and gamma distributions.\n\n\nCode\n# Define parameters for stochastc model\ndays = 20\np = 10000\nnum_E = 10000\nnum_I = 0\nnum_R = 0\n\nbeta_stoch = 0.5*np.ones(days)\n\n# Comparing with previous deterministic model\ninit = 0, p, 0, 0\nsigma = 1/5.2   # 1/5 --&gt; 5 days on average to go from E --&gt; I\nbeta_det = 0.5\ngam = 1/28.85     # 1/11 --&gt; 11 days on average to go from I --&gt; R\nparms = sigma, beta_det, gam\n\n# Run deterministic simulation\nresults_avg = seir_model(init, parms, days)\n\n# Run stochastic simulation with exponential distribution\nresults_stoch_exp = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 'expon', 'expon')\n\n# Run stochastic simulation with gamma distribution\nresults_stoch_gam = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'expon')\n\n\n\n\nCode\nfig = go.Figure(data=[       \n    go.Scatter(name='Exponential', x=np.arange(len(results_stoch_exp[0])), y=100*(1-results_stoch_exp[1]/p), line={'dash':'dash', 'color':'red'}),\n    go.Scatter(name='Gamma', x=np.arange(len(results_stoch_gam[0])), y=100*(1-results_stoch_gam[1]/p), line={'dash':'dash', 'color':'green'}),\n    go.Scatter(name='Deterministic', x=np.linspace(0,days,days*10), y=100*(1-results_avg.T[1]/p), line={'dash':'dot', 'color':'blue'}), \n])\n\nfig.update_layout(\n    title='Number of E moving to I over time when all population is exposed on day 0',\n    xaxis_title='Days',\n    yaxis_title='Percent of exposed having become infectious',\n    legend=dict(\n        x=1,\n        y=1,\n        traceorder=\"normal\",\n    )\n)\n\nfig.show()\n\n\n\n                                                \n\n\nSo we can see using the exponential distribution for \\(T_{Latent}\\) in our stochastic model very closely resembles the deterministic model from part 2.\nWe can see using the gamma distribution forces the behaviour of individual-level disease progression also.\n\n\nI → R\nNow let’s set all individuals to infectious on day 0 and see the progression to R with exponential, gamma, and Weibull distributions.\n\n\nCode\n# Define parameters for stochastc model\ndays = 100\np = 10000\nnum_E = 0\nnum_I = 10000\nnum_R = 0\n\nbeta_stoch = 0.5*np.ones(days)\n\n# Comparing with previous average deterministic model\ninit = 0, 0, p, 0\nsigma = 1/5.2   # 1/5 --&gt; 5 days on average to go from E --&gt; I\nbeta_det = 0.5\ngam = 1/28.85     # 1/11 --&gt; 11 days on average to go from I --&gt; R\nparms = sigma, beta_det, gam\n\n# Run deterministic simulation\nresults_avg = seir_model(init, parms, days)\n\n# Run stochastic simulation with exponential distribution\nresults_stoch_exp = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'expon')\n\n# Run stochastic simulation with gamma distribution\nresults_stoch_gam = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'gamma')\n\n# Run stochastic simulation with gamma distribution\nresults_stoch_wei = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'weibull')\n\n\n\n\nCode\nfig = go.Figure(data=[       \n    go.Scatter(name='Exponential', x=np.arange(len(results_stoch_exp[0])), y=100*(1-results_stoch_exp[2]/p), line={'dash':'dash', 'color':'red'}),\n    go.Scatter(name='Gamma', x=np.arange(len(results_stoch_gam[0])), y=100*(1-results_stoch_gam[2]/p), line={'dash':'dash', 'color':'green'}),\n    go.Scatter(name='Weibull', x=np.arange(len(results_stoch_wei[0])), y=100*(1-results_stoch_wei[2]/p), line={'dash':'dash', 'color':'orange'}),\n    go.Scatter(name='Deterministic', x=np.linspace(0,days,days*10), y=100*(1-results_avg.T[2]/p), line={'dash':'dot', 'color':'blue'}), \n])\n\nfig.update_layout(\n    title='Number of I moving to R over time when all population is infectious on day 0',\n    xaxis_title='Days',\n    yaxis_title='Percent of infectious having become recovered',\n    legend=dict(\n        x=1,\n        y=1,\n        traceorder=\"normal\",\n    )\n)\n\nfig.show()\n\n\n\n                                                \n\n\nSo we can see using the exponential distribution for \\(\\gamma\\) in our stochastic model very closely resembles the deterministic model from part 2.\nWe can see using the gamma or Weibull distributions forces the behaviour of individual-level disease progression also and results in a vastly different picture for progression from I → R."
  },
  {
    "objectID": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#comparing-deterministic-with-stochastic-seir-models",
    "href": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#comparing-deterministic-with-stochastic-seir-models",
    "title": "Epidemic modeling - Part 4",
    "section": "Comparing deterministic with stochastic SEIR models",
    "text": "Comparing deterministic with stochastic SEIR models\nNow that we know our model works, let’s quickly see the effect of stochasticity on the model.\nWe use the deterministic model from blog pat 2 as basis, and so the stochastic model here will use exponential distributions for \\(\\sigma\\) and \\(\\gamma\\).\n\n\nCode\n# Define parameters for stochastic model\ndays = 200\np = 10000\nnum_E = 1\nnum_I = 0\nnum_R = 0\nbeta_stoch = 0.5*np.ones(days)\n\n# Define parameters for deterministic model\ninit = 1-(num_E/p)-(num_I/p)-(num_R/p), num_E/p, num_I/p, num_R/p\nsigma = 1/5.2   # 1/5 --&gt; 5 days on average to go from E --&gt; I\nbeta_det = 0.5\ngam = 1/28.85     # 1/11 --&gt; 11 days on average to go from I --&gt; R\nparms = sigma, beta_det, gam\n\n# Run deterministic simulation\nresults_avg = seir_model(init, parms, days)\n\n# Run 3 stochastic simulations\nresults_stoch1 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 'expon', 'expon')\nresults_stoch2 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 'expon', 'expon')\nresults_stoch3 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 'expon', 'expon')\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='S_det', x=np.linspace(0,days,days*10), y=results_avg.T[0], line={'dash':'solid', 'color':'blue'}, legendgroup=\"det\"),\n    go.Scatter(name='E_det', x=np.linspace(0,days,days*10), y=results_avg.T[1], line={'dash':'solid', 'color':'yellow'}, legendgroup=\"det\"), \n    go.Scatter(name='I_det', x=np.linspace(0,days,days*10), y=results_avg.T[2], line={'dash':'solid', 'color':'red'}, legendgroup=\"det\"),\n    go.Scatter(name='R_det', x=np.linspace(0,days,days*10), y=results_avg.T[3], line={'dash':'solid', 'color':'green'}, legendgroup=\"det\"),\n    go.Scatter(name='S_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='E_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[1]/p, line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='I_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='R_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='S_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='E_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[1]/p, line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='I_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='R_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='S_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='E_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[1]/p, line={'dash':'dot', 'color':'yellow'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='I_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='R_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch3\")\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of stochasticity on Deterministic SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nWe can see very similar curves. The stochasticity appears to influence the time at which the epidemic starts but not the shape of the curves."
  },
  {
    "objectID": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#sigma-exponential-or-gamma-distribution",
    "href": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#sigma-exponential-or-gamma-distribution",
    "title": "Epidemic modeling - Part 4",
    "section": "\\(\\sigma\\): exponential or gamma distribution",
    "text": "\\(\\sigma\\): exponential or gamma distribution\nIn this section we want to examine the effect of a gamma distribution has on the SEIR model (we keep exponential distribution for \\(\\gamma\\)).\n\n\nCode\n# Define parameters for stochastic model\ndays = 200\np = 10000\nnum_E = 1\nnum_I = 0\nnum_R = 0\nbeta_stoch = 0.5*np.ones(days)\n\n# Run 4 stochastic simulations, 2 with exponential sigma, 2 with gamma sigma\nresults_stoch0 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 'expon', 'expon')\nresults_stoch1 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 'expon', 'expon')\nresults_stoch2 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'expon')\nresults_stoch3 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'expon')\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='S_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[0]/p, line={'dash':'solid', 'color':'blue'}, legendgroup=\"det\"),\n    go.Scatter(name='E_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[1]/p, line={'dash':'solid', 'color':'yellow'}, legendgroup=\"det\"), \n    go.Scatter(name='I_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[2]/p, line={'dash':'solid', 'color':'red'}, legendgroup=\"det\"),\n    go.Scatter(name='R_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[3]/p, line={'dash':'solid', 'color':'green'}, legendgroup=\"det\"),\n    go.Scatter(name='S_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[0]/p, line={'dash':'solid', 'color':'blue'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='E_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[1]/p, line={'dash':'solid','color':'yellow'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='I_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[2]/p, line={'dash':'solid', 'color':'red'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='R_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[3]/p, line={'dash':'solid', 'color':'green'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='S_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='E_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[1]/p, line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='I_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='R_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='S_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='E_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[1]/p, line={'dash':'dot', 'color':'yellow'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='I_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='R_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch3\")\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of gamma vs. exponential distributed } \\sigma \\text{ on SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nAs you can see here, it is difficult to tell how much the gamma distributed \\(\\sigma\\) differs from the exponential distributed model (other than just timing).\nThe infectious peak might be a little lower and delayed a bit with gama distribution, but it is hard to tell for sure from this.\nThe peak of exposed individuals seems to be a bit higher and delayed with gamma distribution versus exponential distribution."
  },
  {
    "objectID": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#gamma-exponential-gamma-or-weibull-distribution",
    "href": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#gamma-exponential-gamma-or-weibull-distribution",
    "title": "Epidemic modeling - Part 4",
    "section": "\\(\\gamma\\): exponential, gamma, or Weibull distribution",
    "text": "\\(\\gamma\\): exponential, gamma, or Weibull distribution\nIn this section we want to examine the effect of having \\(T_{Infectious}\\) be gamma or Weibull distribution on the SEIR model.\n\nExponential vs. Gamma\n\n\nCode\n# Define parameters for stochastic model\ndays = 200\np = 10000\nnum_E = 1\nnum_I = 0\nnum_R = 0\nbeta_stoch = 0.5*np.ones(days)\n\n# Run 4 stochastic simulations, 2 with exponential sigma, 2 with gamma sigma\nresults_stoch0 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'expon')\nresults_stoch1 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'expon')\nresults_stoch2 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'gamma')\nresults_stoch3 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'gamma')\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='S_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[0]/p, line={'dash':'solid', 'color':'blue'}, legendgroup=\"det\"),\n    go.Scatter(name='E_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[1]/p, line={'dash':'solid', 'color':'yellow'}, legendgroup=\"det\"), \n    go.Scatter(name='I_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[2]/p, line={'dash':'solid', 'color':'red'}, legendgroup=\"det\"),\n    go.Scatter(name='R_stoch_exp1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[3]/p, line={'dash':'solid', 'color':'green'}, legendgroup=\"det\"),\n    go.Scatter(name='S_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[0]/p, line={'dash':'solid', 'color':'blue'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='E_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[1]/p, line={'dash':'solid','color':'yellow'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='I_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[2]/p, line={'dash':'solid', 'color':'red'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='R_stoch_exp2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[3]/p, line={'dash':'solid', 'color':'green'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='S_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='E_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[1]/p, line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='I_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='R_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='S_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='E_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[1]/p, line={'dash':'dot', 'color':'yellow'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='I_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='R_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch3\")\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of gamma vs. exponential distributed } \\gamma \\text{ on SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nAs you can see here, it is a lot easier to differentiate between the two.\nA gamma distributed \\(\\gamma\\) results in a higher peak of infectious people and underlines how using the usual deterministic models can vastly underestimate peak infectious people.\n\n\nGamma vs. Weibull\n\n\nCode\n# Define parameters for stochastic model\ndays = 200\np = 10000\nnum_E = 1\nnum_I = 0\nnum_R = 0\nbeta_stoch = 0.5*np.ones(days)\n\n# Run 4 stochastic simulations, 2 with exponential sigma, 2 with gamma sigma\nresults_stoch0 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'weibull')\nresults_stoch1 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'weibull')\nresults_stoch2 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'gamma')\nresults_stoch3 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'gamma')\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='S_stoch_wei1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[0]/p, line={'dash':'solid', 'color':'blue'}, legendgroup=\"det\"),\n    go.Scatter(name='E_stoch_wei1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[1]/p, line={'dash':'solid', 'color':'yellow'}, legendgroup=\"det\"), \n    go.Scatter(name='I_stoch_wei1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[2]/p, line={'dash':'solid', 'color':'red'}, legendgroup=\"det\"),\n    go.Scatter(name='R_stoch_wei1', x=np.arange(len(results_stoch0[0])), y=results_stoch0[3]/p, line={'dash':'solid', 'color':'green'}, legendgroup=\"det\"),\n    go.Scatter(name='S_stoch_wei2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[0]/p, line={'dash':'solid', 'color':'blue'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='E_stoch_wei2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[1]/p, line={'dash':'solid','color':'yellow'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='I_stoch_wei2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[2]/p, line={'dash':'solid', 'color':'red'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='R_stoch_wei2', x=np.arange(len(results_stoch1[0])), y=results_stoch1[3]/p, line={'dash':'solid', 'color':'green'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='S_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='E_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[1]/p, line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='I_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='R_stoch_gam1', x=np.arange(len(results_stoch2[0])), y=results_stoch2[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='S_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[0]/p, line={'dash':'dot', 'color':'blue'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='E_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[1]/p, line={'dash':'dot', 'color':'yellow'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='I_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[2]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='R_stoch_gam2', x=np.arange(len(results_stoch3[0])), y=results_stoch3[3]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch3\")\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of Weibull vs. gamma distributed } \\gamma \\text{ on SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nOverall both the gamma and Weibull distributions were very close to the actual distribution for COVID-19 \\(T_{Infectious}\\) so it makes sense that the simulations results in similar curbs here."
  },
  {
    "objectID": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#impact-of-distribution-of-t_infectious-on-infectious-peak",
    "href": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#impact-of-distribution-of-t_infectious-on-infectious-peak",
    "title": "Epidemic modeling - Part 4",
    "section": "Impact of distribution of \\(T_{Infectious}\\) on Infectious Peak",
    "text": "Impact of distribution of \\(T_{Infectious}\\) on Infectious Peak\nIn the plots above we can see the peak of infectious individuals is higher in the simulations done with Gamma or Weibull distributions than in those done with the exponential distribution.\nNote we have not changed anything for \\(\\beta\\) and in the simulations above we have the following:\n\nExponential distribution:\n\n\\[E[T_{Infectious}] = 28.85\\ days\\] \\[R_0 = \\beta * E[T_{Infectious}] = 14.43\\]\n\nGamma distribution:\n\n\\[E[T_{Infectious}] = 20.05\\ days\\] \\[R_0 = \\beta * E[T_{Infectious}] = 10.03\\]\n\nWeibull distribution:\n\n\\[E[T_{Infectious}] = 20.77\\ days\\] \\[R_0 = \\beta * E[T_{Infectious}] = 10.39\\]\nSo while we have a higher \\(R_0\\) when using the exonential distribution for \\(T_{Infectious}\\), the peak of infectious individuals is lower than in the simulations using gamma and Weibull distributions with lower \\(R_0\\).\nWe had previously seen that increasing \\(R_0\\) resulted in high infectious peaks, but this is only true when comparing similar distributions."
  },
  {
    "objectID": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#discussion",
    "href": "posts/2020-03-31-stochastic_model/2020-03-31-stochastic_model.html#discussion",
    "title": "Epidemic modeling - Part 4",
    "section": "Discussion",
    "text": "Discussion\nWe can see the actual distribution of \\(\\sigma\\) and \\(\\gamma\\) carry importance in the resulting SEIR models.\n\n\\(R_0\\)\nIn part 1 we saw that \\(R_0\\) was fully characterized by \\(\\beta\\) and \\(\\gamma\\) in the sense that\n\\[R_0 = \\frac{\\beta}{\\gamma}\\]\nWe can clearly see here however that \\(R_0\\) is not a good enough measure the indicate peak infectious individuals - which is closely related to the peak number of sick individuals which in turn determines required sanitary resources.\nThe actual distribution of \\(T_{Infectious}\\) mus tbe taken into account to estimate true values of peaks.\n\n\nFurther questions\nA couple questions are left to be answered:\n\nHow can we control the spread of an epidemic?\nHow can we evaluate \\(\\beta\\) from the data collected on a population level?\n\nSee further blog posts."
  },
  {
    "objectID": "posts/2021_05_05_stochastic_HIV_model/2021_05_05_stochastic_HIV_model.html#building-a-stochastic-model",
    "href": "posts/2021_05_05_stochastic_HIV_model/2021_05_05_stochastic_HIV_model.html#building-a-stochastic-model",
    "title": "HIV modeling",
    "section": "Building a stochastic model",
    "text": "Building a stochastic model\nThis model is going to focus on individual level disease dynamics to model the disease propagation.\nIt models DHS dataset which contains a homogeneous population between 15 and 49 years old.\nThe basic idea of this model is to have a dataframe with the number of rows equal to the population size (each individual is a row) and two columns: * State column to describe the state of each individual (S, I, or D) * Year column to save the day of transition of the individual into that state * Age column to know the age of the individuals\nHowever, the population-level rates of transmission still apply here i.e. a person goes from S → I following two points: 1. the effective contact rate \\(\\beta\\), which is itself given by: - the number of contacts the person has per unit time (given by \\(r\\)) - the chance of an S contracting the disease from a contact with an I (given by \\(\\rho\\)) 2. the chance a given contact is with an I - infectious individual (the higher the number of I, the higher the chance)\nThis is done stochastically.\nOnce a person becomes I, their progression is unique to them. This progression is calculated in advance for computational reason, but it allows to use the time ditributions we want.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport math\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\nfrom numpy.random import default_rng\nrng = default_rng()\nimport tqdm\nimport time\n\n\n\nCreating the initial population dataframe\nBelow is a function to create the initial population dataframe: * \\(p\\) is the population number * \\(num_I\\) is the number of infectious on day 0 * \\(num_R\\) is the number of people recovered on day 0\n\n\nCode\n# Need this new function for model below:\ndef make_df(p, num_I, num_R):\n  df = pd.DataFrame(np.full((p,1), 'S').T[0], columns=['State'])\n  df['Year'] = 0\n  df['Age'] = (np.random.random(p)*35+15).astype(int)\n  tochange=df.loc[rng.choice(p, size=num_I+num_R, replace=False),'State'].index\n  df.loc[tochange[0:num_I],'State'] = 'I'\n  df.loc[tochange[num_I:num_I+num_R],'State'] = 'R'\n  return df\n\n\n\n\nBuilding the model\n\n\nCode\n# Modelling the decrease of beta over time\n\n#np.random.random(size=(p,days))\n#np.log(4)\nj=12\nover = 10\n\n#10/np.cumsum(np.ones(100))\n\nb1 = 0.25  # original beta = beta value before epidemic\nb2 = 0.05 # end beta = beta at the end of epidemic\nb2 + (b1/np.exp((j+(b1*2.9)-over+1)/(b1*27)))\n\n\nnp.float64(0.19397059336956546)\n\n\n\n\nCode\ndef seir_model_stoch(beta, beta2, p, num_I, num_R, years, T_Infectious, ART, control):\n\n    ################################\n    #### Explanation of inputs  ####\n    ################################\n\n    #### As seen in SSA, beta has a starting value, but after a certain threshold (as soon as incidence or prevalence reaches a certain threshold) behaviours change and beta decreases\n    # beta is initial value of beta at start of epidemic (usually 0.3, but can range from 0.2 to 0.5 as seen in SSA)\n    # beta2 is final value (usually around 0.05)\n    # p is total number of individuals in population\n    # num_I is initial number of PLWHA in population (for simulations start with something between 1 and 10 depending on size of p)\n    # num_R is initial number of people deceased from HIV/AIDS\n    # years is number of years you want to run simulation for\n    # T_infectious is distribution of progression of HIV in an individual (use 'gamma' for HIV)\n    # ART is to emulate ART usage:\n        # ART == 0 means no ART\n        # ART == 1 means ART stops evolution of I to R but does not stop spread from I to S\n        # ART == 2 means ART stops both I to R, and S to I\n    # control sets the threshold at which beta above will decrease\n        # control == 0 means no control i.e. beta never decreases\n        # control == 1 means beta decreases once incidence is 15 per 1 thousand population\n        # control == 2 means beta decreases once incidence is 30 per 1 thousand population\n\n\n    ################################\n    ##### Set up the dataframe #####\n    ################################\n\n    # Initialize population dataframe with data given by user\n    df = make_df(p, num_I, num_R)\n    \n    # This variable is used to track daily value of beta if it varies over time\n    xxbeta=np.array([],dtype=float)\n\n    # Initialize the arrays to return\n    # Below are numbers of S, I, R total\n    S=np.array([],dtype=int)\n    I=np.array([],dtype=int)\n    R=np.array([],dtype=int)\n    # Below are the daily additions in S, I, R\n    Spd=np.array([],dtype=int)\n    Ipd=np.array([],dtype=int)\n    Rpd=np.array([],dtype=int)\n\n    # Beta values to track spread\n    b=beta\n    b2=np.array([],dtype=float)\n    b1=b\n\n    # Signal to initiate decrease of beta\n    over = 0 \n\n    # signal to end transmission and deaths due to ART\n    art1 = 0\n    art2 = 0\n    \n    # Stochastic model so use random values to decide on progression\n    rand = np.random.random(size=(p,years))\n\n    # Depending if you want exponential, gamma, or Weibull distribution for T_Infectious\n    # Uses distributions found on blog part 3\n    if T_Infectious == 'expon':\n      ItoR = expon.rvs(loc=0,scale=10,size=p)\n    elif T_Infectious == 'gamma':\n      ItoR = gamma.rvs(4,loc=3,scale=2,size=p)    \n    else:\n      ItoR = weibull_min.rvs(2.3, loc=2, scale=20.11, size=p)\n\n\n    ################################\n    ####### Simulation code ########\n    ################################\n\n    # Iterate over every day the simulation is run\n    for j in range(0,years-1):\n\n        # Record daily beta values\n        xxbeta=np.append(xxbeta, b[j])\n\n        # First we get the index of the individuals that will change state today:\n\n        # Random number tells you which 'S' have been exposed on this day \n        if ART &lt; 2:\n          StoI_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n          StoS_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &gt;= b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n        elif ART == 2: \n          if art2 == 0:\n            StoI_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n            StoS_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &gt;= b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n          elif art2 == 1:\n            StoI_index = df.loc[(df.State == 'S') & (df.Age &gt; 55)].index # cannot happen so put an impossible condition like df.Age &gt; 55 to emulate\n            StoS_index = df.loc[(df.State == 'S') & (df.Age &lt; 49)].index # anyone S under 49 will stay S\n\n        StoRem_index = df.loc[(df.State == 'S') & (df.Age &gt;= 49)].index\n        \n        # For each row, if a person has been a certain number of years in I, they will go to R (progression to AIDS and death)\n        # This follows ItoR variable which is either exponential or gamma distributed according to above\n        ItoRem_index = df.loc[(df.State == 'I') & (df.Age &gt;= 49)].index\n        if ART == 0: #don't use ART\n          ItoR_index = df.loc[(df.State == 'I') & (j-df.Year &gt;= ItoR) & (df.Age &lt; 49)].index\n          ItoI_index = df.loc[(df.State == 'I') & (j-df.Year &lt; ItoR) & (df.Age &lt; 49)].index\n        elif ART &gt; 0:\n          if art2 == 0:\n            ItoR_index = df.loc[(df.State == 'I') & (j-df.Year &gt;= ItoR) & (df.Age &lt; 49)].index\n            ItoI_index = df.loc[(df.State == 'I') & (j-df.Year &lt; ItoR) & (df.Age &lt; 49)].index\n          elif art2 ==1:\n            ItoR_index = df.loc[(df.State == 'I') & (df.Age &gt; 55)].index # cannot happen so impossible condition\n            ItoI_index = df.loc[(df.State == 'I') & (df.Age &lt; 49)].index            \n\n        RtoRem_index = df.loc[(df.State == 'R') & (df.Age &gt;= 49)].index\n\n        RtoR_index = df.loc[(df.State == 'R') & (df.Age &lt; 49)].index\n\n        # Use indexes collected above to populate per day values\n        Ipd = np.append(Ipd,len(StoI_index))\n        Rpd = np.append(Rpd,len(ItoR_index))\n\n        # Now we use the indexes collected above randomly to change the actual population dataframe to the new states\n        df.loc[ItoR_index, ['State','Year']] = ['S', j]\n        df.loc[ItoR_index, 'Age'] = df.loc[ItoR_index, 'Age'] + 1\n        df.loc[ItoI_index, 'Age'] = df.loc[ItoI_index, 'Age'] + 1\n        \n        df.loc[StoI_index, ['State','Year']] = ['I', j]\n        df.loc[StoI_index, 'Age'] = df.loc[StoI_index, 'Age'] + 1\n        df.loc[StoS_index, 'Age'] = df.loc[StoS_index, 'Age'] + 1\n        \n        df.loc[RtoR_index, 'Age'] = df.loc[RtoR_index, 'Age'] + 1\n\n        df.iloc[ItoRem_index] = ['S', j, 15]\n        df.iloc[StoRem_index] = ['S', j, 15]\n        df.iloc[RtoRem_index] = ['S', j, 15]\n\n        # Append the S, I, and R arrays\n        S=np.append(S,len(np.where(df.State=='S')[0]))\n        I=np.append(I,len(np.where(df.State=='I')[0]))\n        R=np.append(R,len(np.where(df.State=='R')[0]))\n\n        # Code below for control measures to reduce beta values\n        if control == 1:\n          if (I[-1]/p &gt; 0.006):\n            art1 = 1\n            if over == 0:\n              over = j\n          \n          if art1 == 1:\n            if j &gt; over + 15:    \n              art2 = 1\n\n          if over != 0:\n            b = beta2 + (b1/np.exp((j+(b1*2.9)-over+1)/(b1*27)))\n\n        if control == 2:\n          if (I[-1]/p &gt; 0.01):\n            art1 = 1\n            if over == 0:\n              over = j\n          \n          if art1 == 1:\n            if j &gt; over + 15:    \n              art2 = 1\n\n          if over != 0:\n            b = beta2 + (b1/np.exp((j+(b1*2.9)-over+1)/(b1*27)))\n\n\n        xxbeta2 = ((S[j-1]+I[j-1])/I[j-1])*Ipd[j]/S[j-1]\n        b2 = np.append(b2, xxbeta2)\n                \n    Ipd[0]+=num_I\n    Rpd[0]+=num_R\n\n    return S, I, R, Spd, Ipd, Rpd, xxbeta, b2, over"
  },
  {
    "objectID": "posts/2021_05_05_stochastic_HIV_model/2021_05_05_stochastic_HIV_model.html#testing-the-model",
    "href": "posts/2021_05_05_stochastic_HIV_model/2021_05_05_stochastic_HIV_model.html#testing-the-model",
    "title": "HIV modeling",
    "section": "Testing the model",
    "text": "Testing the model\n\n\nCode\n# Define parameters for stochastic model\nyears = 50\np = 100000\nnum_E = 0\nnum_I = 50\nnum_R = 0\nbeta_stoch = [0.17,0.17,0.26,0.26,0.36,0.36]\n#beta_stoch = np.linspace(0.2,0.5,num=10)\n#beta_stoch = [0.1,0.1,0.1,0.1,0.1,0.1]\nbeta_stoch2 = [0.05,0.05,0.05,0.05,0.05,0.05]\n#beta_stoch = beta_stoch2\n\ncontrol= [1,1,1,1,2,2]\n\nn = len(beta_stoch)\n\nresults_stoch = []\n\n# Run n stochastic simulations\nfor i in tqdm.tqdm(range(n)):\n  res = seir_model_stoch(beta_stoch[i]*np.ones(years),beta_stoch2[i], p, num_I, num_R, years, 'gamma', 0, control[i])\n  results_stoch.append(res)\n\n\n100%|██████████| 6/6 [00:17&lt;00:00,  2.84s/it]\n\n\n\n\nCode\nfig = go.Figure()\n\nfor i in range(len(results_stoch)):\n  #fig.add_trace(go.Scatter(name='Beta_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[6], line={'dash':'dot','color':'yellow'}, legendgroup=\"Sim_\"+str(i)))\n  fig.add_trace(go.Scatter(name='Beta_meas'+str(i), x=np.arange(len(results_stoch[i][0])), y=results_stoch[i][7], line={'dash':'dot','color':'yellow'}, legendgroup=\"Sim_\"+str(i)))\n  fig.add_trace(go.Scatter(name='I_stoch'+str(i), x=np.arange(len(results_stoch[i][0])), y=results_stoch[i][1]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"Sim_\"+str(i)))\n  fig.add_trace(go.Bar(name='Ip_stoch'+str(i), x=np.arange(len(results_stoch[i][0])), y=results_stoch[i][4]*10/p, legendgroup=\"Sim_\"+str(i)))\n  fig.add_trace(go.Scatter(name='R_stoch'+str(i), x=np.arange(len(results_stoch[i][0])), y=results_stoch[i][2]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"Sim_\"+str(i)))\n\nfig.update_layout(\n    xaxis_title = 'Years',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':'Stochastic HIV SIR model',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html",
    "href": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html",
    "title": "Epidemic modeling - Part 1",
    "section": "",
    "text": "This is the 1st part of a multi-part series blog post on modeling in epidemiology.\nThe COVID-19 pandemic has brought a lot of attention to the study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on a few important points.\nIn this first post I want to introduce the concept of compartmentalization and how it forms the basis for studying disease dynamics on the population level."
  },
  {
    "objectID": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#motivation-for-write-up",
    "href": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 1",
    "section": "",
    "text": "This is the 1st part of a multi-part series blog post on modeling in epidemiology.\nThe COVID-19 pandemic has brought a lot of attention to the study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on a few important points.\nIn this first post I want to introduce the concept of compartmentalization and how it forms the basis for studying disease dynamics on the population level."
  },
  {
    "objectID": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#how-to-model-infectious-diseases-on-population-level",
    "href": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#how-to-model-infectious-diseases-on-population-level",
    "title": "Epidemic modeling - Part 1",
    "section": "How to model infectious diseases on population level ?",
    "text": "How to model infectious diseases on population level ?\n\nCompartments\nWhen modelling infectious diseases, and pandemics in particular, a key ask is to predict the number of infected people at any given time in order to estimate the sanitary resources that will be necessary.\nFrom this simple qestion results the idea of compartmentalization of the population i.e. the division of the population into the two most basic categories:\n\nthose that are infected\nthose that are not\n\nThis is ultimately the foundation for all compartmental models in epidemiology.\nThe nuances between the models then come from how the above two groups are further compartmentalized. That is to say, how we decide the composition of the infected and the not-infected groups.\nFor example, the non-infected group could be further sub-categorized into:\n\nSusceptible\nImmune\n\nAnd the infected group into:\n\nAsymptomatic\nSymptomatic\n\nOr, another option, into:\n\nNo treatment necessary\nRequire treatment:\n\nLocal Doctor visit\nHospitalization\nAdmitted to intensive care unit\n\n\nAs you can see there are many ways to do this, but the more categories you have, the more difficult it might become to model. Usually we determine these subcategories in order to match available data.\n\n\nDynamics\nWhile the compartments describe the state any individual can be in at a certain point in time, the dynamics describe the ways in which the compartments interact with each other.\nI want to underline the separation between disease dynamics on the individual level, and that on the population level below.\n\nIndividual level disease dynamics:\n\nThis describes, on the individual level, the progression of the disease i.e. how one person can go from one state to another (one compartment to another)\nFor example: how does a healthy person become ill and what is the clinical course of the disease for this person?\n\nPopulation-level dynamics:\n\nOn the other hand, the population level dynamics describe, on a population level, how the total number of individuals in each compartment vary over time.\nWe will see more on this in the next blog posts.\n\n\nTwo simple examples - the SIR and SEIR models\nLet’s have a look at a basic compartmental model, first the SIR model.\n\nS –&gt; Susceptible state:\n\nAn S individual is simply someone susceptible to the disease, that is anyone in the population who is healthy and not immune to the disease.\n\nI –&gt; Infectious state:\n\nOnce an individual is exposed to the disease he will develop this disease and become infectious.\n\nR –&gt; Recovered state:\n\nAn individual will either fight off the infection (with the help or not of treatment) or die. These are all included in the R state.\nIn the basic SIR model, anyone R has aquired full and infinite immunity and cannot catch the disease again (of course many variations can be included to reflect more closely a disease).\nIn this write-up and in the following blog posts we will focus on the SEIR models, which are similar to the SIR compartments above with the additional E state between S and I.\n\nE –&gt; Exposed state:\n\nThe exposed state is the state when an individual has been exposed to the disease, but has not become infectious yet.\n\n\nSome important vocabulary\n\n\\(\\underline{Infectious\\ period:}\\)\n\nAlso called the period of communicability, the infectious period is the time during which an individual can transmit the disease to another: \\(T_{Infectious}\\)\n\n\\(\\underline{Clinical\\ infection\\ period:}\\)\n\nThis period corresponds to the period where the infected indvidual shows symptoms: \\(T_{Clinical}\\)\n\n\\(\\underline{Latent\\ period:}\\)\n\nThe latent period is the time between exposure of an individual and the start of the period of communicability of that individual: \\(T_{Latent}\\)\n\n\\(\\underline{Incubation\\ period:}\\)\n\nThe incubation period on the other hand, is the time from exposure of an individual to development of the infection (appearance of disease): \\(T_{Incubation}\\)\nIt should be noted the latent period and incubation period are not necessarily the same.\n\n\\(\\underline{T_{Latent} &lt; T_{Incubation}}\\):\n\nIn this case, an individual who has been exposed becomes infectious before the development of disease.\nWe call this a subclinical infection and during that time the individual is called an asymptomatic carrier.\n\n\\(\\underline{T_{Latent} &gt; T_{Incubation}:}\\)\n\nIn other cases, the latent period can be longer than the incubation period, eg: smallpox.\n\n\\(\\underline{T_{Latent} + T_{Infectious} &gt; T_{Incubation} + T_{Clinical}:}\\)\n\nAnother case of subclinical infection resulting in asymptomatic carriers occurs when the end of clinical infection (of disease) happens earlier than the end of the period of communicability (see Wikipedia figure below)\nOverall, these asymptomatic carriers can be a significant difficutly to overcome epidemics.\n\n\n\\(\\underline{Basic\\ reproduction\\ number:}\\)\n\nThe basic reproduction number \\(R_0\\) is the measure of secondary infections in a susceptible population.\nIn other words, it is the number of people that each infectious individual will infect over the time of their infectious period.\nExample:\nIf an infectious individual infects 3 other individuals over the course of his infection, his \\(R_0\\) is 3.\nThis number is a very important element in the spreading dynamics (see derivation below)."
  },
  {
    "objectID": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#a-closer-look-at-the-seir-model",
    "href": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#a-closer-look-at-the-seir-model",
    "title": "Epidemic modeling - Part 1",
    "section": "A closer look at the SEIR model",
    "text": "A closer look at the SEIR model\n\nIndividual-level disease dynamic\nAs explained above, the individual-level disease dynamic describes the progression of disease within an individual i.e. the progression of an individual from one state to another.\n\nIn the models used here (SEIR model), an individual starts at S (although an initial exposed or infectious person is injected into the population at time t=0).\nIf exposed to the disease he will move into the state E.\nAfter which he will move to the I state with probability 1, but in a time unique to himself.\nAgain after which he will move into the state R with probability 1, and again in a time unique to him.\nFrom state R he will stay in state R (either dead or has aquired full and inifite immunity).\n\nLet’s have a closer look:\n\nS → E\nThe chances of an individual going from S → E depends on three things:\n\nthe number of contacts the person has per unit time (given by \\(r\\))\nthe chance a given contact is with an I - infectious individual (the higher the number of I in the population, the higher the chance)\nthe chance of an S contracting the disease from a contact with an I (given by \\(\\rho\\))\n\n\n\nE → I\nThe latent period\nAll people exposed will eventually develop disease.\nHowever, individually, a person might go from E to I on the first day, or after 10 days, this is unique to the individual.\nEvery additional day following exposure the probability of this individual to go from E → I increases (we will have a look at the probability distribution and its importance later).\n\n\nI → R\nThe period of communicability\nSimilarly, all infectious people will recover (or die).\nAgain, individually, a person might go from I to R in 5 days or in 15 days, this time is the recovery time and is proper to the individual.\n\n\n\nPopulation level dynamics\nMost basic models tend to disregard the notion of individual dynamics above in favor of poopulation level dynamics.\nThat is to say the models tend to model disease on a population level without looking at the specific pogression of disease within the individuals and using averages instead (although the S → E uses the same logic as above).\nBelow is an explanation for such an SEIR model with its mathematical formulation.\nNote no births or deaths are included.\n\nS → E\nAs stated above, going from S to E on a particular day depends on these three characteristics:\n\nthe proportion of infectious people in the population on that day: \\(i(t) = \\frac{I(t)}{N}\\)\nthe number of contacts an individual has per day: \\(r\\)\nthe chance for an S to contract the disease after contact with an I: \\(\\rho\\)\n\nWe can combine the last two into \\(\\beta = r \\rho\\)\nOn a population-level however, the number of S that will become E also depends on the proportion of S in the population (of course if there are no S, no one will become E of course).\nSo we add the following requirement:\n\nthe proportion of susceptible people in the population on that day: \\(s(t) = \\frac{S(t)}{N}\\)\n\nSo the change in the number of S in a population on a given day is equal to:\n\\[ - \\beta i(t) s(t)\\]\n(note the negative sign to indicate the number of S is diminishing as they become exposed)\nHence we can formulate this mathematically as follows:\n\nDiscrete-time: \\[\\Delta S = -\\beta I S\\Delta T\\]\nContinuous-time: \\[\\frac{ds(t)}{dt}=-\\beta i(t) s(t)\\]\n\n\n\nE → I\nWe have seen above how each individual goes from E to I.\nOn a population level, the number of E changes in two ways:\n\nnew additions following S → E\nreduction following E → I\n\nWe already know the number from S → E is:\n\\[\\beta i(t) s(t)\\]\nSo how can we model the number of E → I?\nWhile individually this is a bit more complicated to model and pertains to the specific probability distribution of the latent period, on a population level we can use the average time it takes - this is what most models do (part 3 of this blog post will show why this is wrong for COVID-19).\nLet’s say average latent period is\n\\[\\frac{1}{\\sigma}\\]\nthen we know that every unit time that goes by, we have\n\\[\\sigma E\\]\nindividuals that transition from E → I.\nMathematically, we write this as :\n\nDiscrete-time: \\[\\Delta E = (\\beta I S-\\sigma E) \\Delta T\\]\nContinuous-time: \\[\\frac{de(t)}{dt}=\\beta i(t) s(t) - \\sigma e(t)\\]\n\n\n\nI → R\nSimilarly as above, we have seen above how each individual goes from I to R but this does not tell us about the population level dynamics.\nOn a population level, the number of I changes in two ways:\n\nnew additions following E → I\nreduction following I → R\n\nWe know the number from E → I is:\n\\[\\sigma e(t)\\]\nHow can we model the number of I → R?\nAgain, while individually this is complicated, on a population level, how about averaging out the period of infectiousness, this is what most models do.\nLet’s say average time of infectiousness is\n\\[\\frac{1}{\\gamma}\\]\nThen we have :\n\nDiscrete-time: \\[\\Delta I = (\\sigma E - \\gamma I) \\Delta T\\]\nContinuous-time: \\[\\frac{di(t)}{dt}=\\sigma e(t) - \\gamma i(t)\\]\n\n\n\nR → R\nFinally, it is simple to model the number of individuals in R state with the following equation:\n\nDiscrete-time: \\[\\Delta R = \\gamma I \\Delta T\\]\nContinuous-time: \\[\\frac{dr(t)}{dt}=\\gamma i(t)\\]"
  },
  {
    "objectID": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#effective-and-basic-reproduction-numbers-r-and-r_0-respectively",
    "href": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#effective-and-basic-reproduction-numbers-r-and-r_0-respectively",
    "title": "Epidemic modeling - Part 1",
    "section": "Effective and Basic Reproduction Numbers: \\(R\\) and \\(R_0\\) respectively",
    "text": "Effective and Basic Reproduction Numbers: \\(R\\) and \\(R_0\\) respectively\nAs stated above, \\(R_0\\) is the measure of secondary infections. Let’s have a look how we can characterize it.\n\nUnderstanding how the infection spreads\nAny individual in state I (infectious) will contaminate others according to the following:\n\nNumber of contacts the individual has per day given by: \\(r_i\\)\nProbability to infect an S after contact given by: \\(\\rho_i\\)\nProbability of a contact being with an S given by: \\(\\frac{S(t)}{N} = s(t)\\)\nThe period of infectiousness of the individual given by [\\(j_i, j_i+\\frac{1}{\\tau_i}\\)] (where \\(j_i\\) is the first day of infectiousness for that individual and \\(\\frac{1}{\\tau_i}\\) is that individuals’ time of infectiousness)\n\nRemember \\(r_i\\rho_i=\\beta_i\\)\n\n\nDerivation of \\(R\\) for each individual\nLet’s call the measure of \\(R\\) for any individual \\(R_i\\).\nFrom the parameters above we can write \\(R_i\\) for each infectious individual as the sum of secondary infections per day of infectiousness as below:\n\nDiscrete-time: \\[R_i = \\sum_{Day=j_i}^{j_i+\\frac{1}{\\tau_i}} \\beta_i \\frac{S(Day)}{N}\\] *Continuous-time: \\[R_i = \\int_{j_i}^{j_i+\\frac{1}{\\tau_i}} \\beta_i s(t) dt\\]\n\n\n\nFinding \\(R_0\\) of each individual by making assumptions\n\\(R_{0,i}\\) is the measure of \\(R_i\\) in a susceptible population, i.e. when: \\[S = N\\]\nIn other words: \\[R_{0,i} = R_i ~ \\frac{N}{S}\\]\nIf we make the following assumptions:\n\ns(t) is constant over the course of infectiousness of an individual: \\[s(t) = s(t+\\frac{1}{\\tau_i})\\]\n\\(\\beta_i\\) is a constant and does not vary over the course of time (no control measures)\n\nThen the equation for \\(R_{0,i}\\) reduces to the following: \\[R_{0,i} = [\\beta_i]_{j_i}^{j_i+\\frac{1}{\\tau_i}} = \\frac{\\beta_i}{\\tau_i}\\]\nWe can see the basic reproduction number of an individual is fully characterized by the \\(\\beta_i\\) and the \\(\\tau_i\\) of that individual.\n\n\n\\(R_0\\) for a population\nTo a generalize to a population-level, we can simply find the expected value for the equation above: \\[R_0 = E[R_{0,i}] = \\frac{E[\\beta_i]}{E[\\tau_i]}\\]\nAssuming:\n\n\\(E[\\beta_i] = \\beta\\)\n\\(E[\\tau_i] = \\gamma\\)\n\nWe can write: \\[R_0 = \\frac{\\beta}{\\gamma}\\]"
  },
  {
    "objectID": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#herd-immunity",
    "href": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#herd-immunity",
    "title": "Epidemic modeling - Part 1",
    "section": "Herd Immunity",
    "text": "Herd Immunity\nAs just described, \\(R\\) is the measure of secondary infections, and \\(R_0\\) is the measure of secondary infections in a susceptible population where \\(R=R_0~s(t)\\).\nIt is easy to understand that if each infectious individual contaminates less than 1 other individual on average (\\(R &lt; 1\\)) then the number of exposed, and eventually infectious, individuals will diminish and tend to 0.\nOn the other hand, if each infectious individual contaminates more than 1 other individual (\\(R &gt; 1\\)) then the number of infectious individuals will rise (chance of epidemic).\nMathematical formulation:\n\\[\\frac{d~e(t)}{dt} = \\beta~i(t)~s(t) - \\gamma~i(t)\\] \\[\\leftrightarrow\\frac{d~e(t)}{dt} = R_0~\\gamma~i(t)~s(t) - \\gamma~i(t)\\] \\[\\leftrightarrow\\frac{d~e(t)}{dt} = \\gamma~i(t)~(R_0~s(t) - 1)=\\gamma~i(t)~(R - 1)\\]\nAnd so we find that in a population where \\(\\gammaĩ(t)&gt;0\\): \\[\\frac{d~e(t)}{dt} = 0\\] \\[\\leftrightarrow R-1 = 0\\] \\[\\leftrightarrow R = 1\\]\nIf \\(R&lt;1\\) then \\(\\frac{d~e(t)}{dt} &lt; 0\\)\nHerd immunity threshold:\nThe herd immunity threshold is the point at which enough of the population is immune to the disease (not susceptible) in order to have \\(R &lt; 1\\) and can be calculated as follows: \\[R = R_0 ~ s(t)\\]\nWe know the proportion of the population immune to the disease is: \\[Immune(t) = 1-s(t)\\] \\[\\leftrightarrow\\ s(t)=1-Immune(t)\\]\nThe threshold of \\(R = 1\\) is achieved when: \\[R_0 ~s(t) = 1\\] \\[\\leftrightarrow\\ R_0 ~(1-Immune(t)) = 1\\] \\[\\leftrightarrow\\ 1-Immune(t) = \\frac{1}{R_0}\\] \\[\\leftrightarrow\\ Immune(t) = 1-\\frac{1}{R_0}\\]\nWhen the proportion of immune individuals in a population reaches \\(1-\\frac{1}{R_0}\\) then \\(R\\) will become smaller than 1 and the number of infectious individuals will diminish and tend to 0."
  },
  {
    "objectID": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#conclusion",
    "href": "posts/2020-03-15-compartmentalization/2020-03-15-compartmentalization.html#conclusion",
    "title": "Epidemic modeling - Part 1",
    "section": "Conclusion",
    "text": "Conclusion\nThis was a brief introduction to compartmentalization models and the dynamics associated with them.\nOf course these sort of derivations can be done for many different types of comprtaments and their relevant dynamics, but the SEIR is simple enough to understand and model quickly."
  },
  {
    "objectID": "posts/2021-05-07-stochastic_HIV_model/2021-05-07-stochastic_HIV_model.html#motivation-for-write-up",
    "href": "posts/2021-05-07-stochastic_HIV_model/2021-05-07-stochastic_HIV_model.html#motivation-for-write-up",
    "title": "HIV modeling",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 4th part of a multi-part series blog post on modeling in epidemiology (May 7th, 2021).\nThe COVID-19 pandemic has brought a lot of attention to study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on two key points.\nAfter introducing the concepts of compartmentalization and disease dynamics in the first blog post, the second part looked at a deterministic numerical solution for the SEIR model discussed, and the effects of the parameters \\(\\beta\\), \\(\\sigma\\), and \\(\\gamma\\) in parts 1 and 2.\nPart 3 made the argument that most models ignore individual-level disease dynamics in favor of averaging population-level \\(\\sigma\\) and \\(\\gamma\\) parameters and showed some big discrepancies between actual COVID-19 probability distributions for those parameters and those used in research.\nThis 4th part is where I build a numerical SEIR model that takes into account these probability distributions in order to tweak the model as close to COVID-19 data as possible."
  },
  {
    "objectID": "posts/2021-05-07-stochastic_HIV_model/2021-05-07-stochastic_HIV_model.html#building-a-stochastic-model",
    "href": "posts/2021-05-07-stochastic_HIV_model/2021-05-07-stochastic_HIV_model.html#building-a-stochastic-model",
    "title": "HIV modeling",
    "section": "Building a stochastic model",
    "text": "Building a stochastic model\nAs opposed to the deterministic model from Part 2, this model is going to focus on individual level disease dynamics to model the disease propagation.\nThe basic idea of this model is to have a dataframe with the number of rows equal to the population size (each individual is a row) and two columns: * State column to describe the state of each individual (S, E, I, or R) * Day column to save the day of transition of the individual into that state\nHowever, the population-level rates of transmission still apply here i.e. a person goes from S → E following three points: 1. the number of contacts the person has per unit time (given by \\(r\\)) 2. the chance a given contact is with an I - infectious individual (the higher thenumber of I, the higher the chance) 3. the chance of an S contracting the disease from a contact with an I (given by \\(\\rho\\))\nThis is done stochastically.\nOnce a person becomes E, their progression is unique to them. This progression is calculated in advance for computational reason, but it allows to use the time ditributions we want.\n\n#collapse_hide\n!pip install plotly==4.14.3\nimport pandas as pd\nimport numpy as np\nimport math\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\nfrom numpy.random import default_rng\nrng = default_rng()\n\n# Let's build a numerical solution\ndef seir_model(init, parms, days):\n    S_0, E_0, I_0, R_0 = init\n    Epd, Ipd, Rpd = [0], [0], [0]\n    S, E, I, R = [S_0], [E_0], [I_0], [R_0]\n    dt=0.1\n    t = np.linspace(0,days,int(days/dt))\n    sigma, beta, gam = parms\n    for _ in t[1:]:\n        next_S = S[-1] - beta*S[-1]*I[-1]*dt\n        Epd.append(beta*S[-1]*I[-1]*dt)\n        next_E = E[-1] + (beta*S[-1]*I[-1] - sigma*E[-1])*dt\n        Ipd.append(sigma*E[-1]*dt)\n        next_I = I[-1] + (sigma*E[-1] - gam*I[-1])*dt\n        Rpd.append(gam*I[-1]*dt)\n        next_R = R[-1] + (gam*I[-1])*dt\n        S.append(next_S)\n        E.append(next_E)\n        I.append(next_I)\n        R.append(next_R)\n    return np.stack([S, E, I, R, Epd, Ipd, Rpd]).T\n\nCollecting plotly==4.14.3\n  Downloading https://files.pythonhosted.org/packages/1f/f6/bd3c17c8003b6641df1228e80e1acac97ed8402635e46c2571f8e1ef63af/plotly-4.14.3-py2.py3-none-any.whl (13.2MB)\n     |████████████████████████████████| 13.2MB 303kB/s \nRequirement already satisfied: retrying&gt;=1.3.3 in /usr/local/lib/python3.7/dist-packages (from plotly==4.14.3) (1.3.3)\nRequirement already satisfied: six in /usr/local/lib/python3.7/dist-packages (from plotly==4.14.3) (1.15.0)\nInstalling collected packages: plotly\n  Found existing installation: plotly 4.4.1\n    Uninstalling plotly-4.4.1:\n      Successfully uninstalled plotly-4.4.1\nSuccessfully installed plotly-4.14.3\n\n\n\nCreating the initial population dataframe\nBelow is a function to create the initial population dataframe: * \\(p\\) is the population number * \\(num_E\\) is the number of people exposed on day 0 * \\(num_I\\) is the number of infectious on day 0 * \\(num_R\\) is the number of people recovered on day 0\n\n#collapse_hide\n# Need this new function for model below:\ndef make_df(p, num_I, num_R):\n  df = pd.DataFrame(np.full((p,1), 'S').T[0], columns=['State'])\n  df['Year'] = 0\n  df['Age'] = (np.random.random(p)*35+15).astype(int)\n  tochange=df.loc[rng.choice(p, size=num_I+num_R, replace=False),'State'].index\n  df.loc[tochange[0:num_I],'State'] = 'I'\n  df.loc[tochange[num_I:num_I+num_R],'State'] = 'R'\n  return df\n\n\n\nBuilding the model\n\n#np.random.random(size=(p,days))\n#np.log(4)\nj=11\nover = 10\n#10/np.cumsum(np.ones(100))\n0.05 + (0.3/np.exp((j+1-over)/10))\n\n0.29561922592339457\n\n\n\n#collapse_hide\ndef seir_model_stoch(beta, beta2, p, num_I, num_R, years, T_Infectious, ART, control):\n\n    # Initialize population dataframe with data given by user\n    df = make_df(p, num_I, num_R)\n    \n    # This variable is used to track daily value of beta if it varies over time\n    xxbeta=np.array([],dtype=float)\n\n    # Initialize the arrays to return\n    # Below are numbers of S, I, R total\n    S=np.array([],dtype=int)\n    I=np.array([],dtype=int)\n    R=np.array([],dtype=int)\n    # Below are the daily additions in S, I, R\n    Spd=np.array([],dtype=int)\n    Ipd=np.array([],dtype=int)\n    Rpd=np.array([],dtype=int)\n\n    b=beta\n    #b2=beta[0]\n    b2=np.array([],dtype=float)\n    b1=b\n\n    # signal diminshing beta\n    over = 0 \n\n    # signal end of deaths due to ART\n    art1 = 0\n    art2 = 0\n\n    \n    # Stochastic model so use random values to decide on progression\n    rand = np.random.random(size=(p,years))\n\n    # Depending if you want exponential, gamma, or Weibull distribution for T_Infectious\n    # Uses distributions found on blog part 3\n    if T_Infectious == 'expon':\n      ItoR = expon.rvs(loc=0,scale=10,size=p)\n    elif T_Infectious == 'gamma':\n      ItoR = gamma.rvs(4,loc=3,scale=2,size=p)    \n    else:\n      ItoR = weibull_min.rvs(2.3, loc=2, scale=20.11, size=p)\n\n    # Iterate over every day the simulation is run\n    for j in range(0,years-1):\n\n        # Record daily beta values\n        xxbeta=np.append(xxbeta, b[j])\n\n        # First we get the index of the individuals that will change state today:\n\n        # Random number tells you which 'S' have been exposed on this day \n        #StoE_index = df.loc[(df.State == 'S') & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/p)].index\n        if ART &lt; 2:\n          StoI_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n          StoS_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n        elif ART == 2:\n          if art2 == 0:\n            StoI_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n            StoS_index = df.loc[(df.State == 'S') & (df.Age &lt; 49) & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/(len(np.where(df.State=='I')[0])+len(np.where(df.State=='S')[0])))].index\n          elif art2 == 1:\n            StoI_index = df.loc[(df.State == 'S') & (df.Age &gt; 55)].index\n            StoS_index = df.loc[(df.State == 'S') & (df.Age &lt; 49)].index\n\n        StoRem_index = df.loc[(df.State == 'S') & (df.Age == 49)].index\n\n        # For each row, if a person has been a certain number of days in E, they will go to I\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        #EtoI_index = df.loc[(df.State == 'E') & (j-df.Day &gt;= EtoI)].index\n        \n        # Similaraly as above\n        # For each row, if a person has been a certain number of days in I, they will go to R\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        ItoRem_index = df.loc[(df.State == 'I') & (df.Age == 49)].index\n        if ART == 0: #don't use ART\n          ItoR_index = df.loc[(df.State == 'I') & (j-df.Year &gt;= ItoR) & (df.Age &lt; 49)].index\n          ItoI_index = df.loc[(df.State == 'I') & (j-df.Year &lt; ItoR) & (df.Age &lt; 49)].index\n        elif ART &gt; 0:\n          if art2 == 0:\n            ItoR_index = df.loc[(df.State == 'I') & (j-df.Year &gt;= ItoR) & (df.Age &lt; 49)].index\n            ItoI_index = df.loc[(df.State == 'I') & (j-df.Year &lt; ItoR) & (df.Age &lt; 49)].index\n          elif art2 ==1:\n            ItoR_index = df.loc[(df.State == 'I') & (df.Age &gt; 49)].index\n            ItoI_index = df.loc[(df.State == 'I') & (df.Age &lt; 49)].index            \n\n        RtoRem_index = df.loc[(df.State == 'R') & (df.Age == 49)].index\n        RtoR_index = df.loc[(df.State == 'R') & (df.Age &lt; 49)].index\n\n        # Use indexes collected above to populate per day values\n        #Epd = np.append(Epd,len(StoE_index))\n        #Ipd = np.append(Ipd,len(EtoI_index))\n        Ipd = np.append(Ipd,len(StoI_index))\n        Rpd = np.append(Rpd,len(ItoR_index))\n\n        # Now we use the indexes collected above randomly to change the actual population dataframe to the new states\n        df.iloc[ItoRem_index] = ['S', j, 15]\n        df.loc[ItoR_index, ['State','Year']] = ['S', j]\n        df.loc[ItoR_index, 'Age'] = df.loc[ItoR_index, 'Age'] + 1\n        df.loc[ItoI_index, 'Age'] = df.loc[ItoI_index, 'Age'] + 1\n        df.iloc[StoRem_index] = ['S', j, 15]\n        df.loc[StoI_index, ['State','Year']] = ['I', j]\n        df.loc[StoI_index, 'Age'] = df.loc[StoI_index, 'Age'] + 1\n        df.loc[StoS_index, 'Age'] = df.loc[StoS_index, 'Age'] + 1\n        \n        df.iloc[RtoRem_index] = ['S', j, 15]\n        df.loc[RtoR_index, 'Age'] = df.loc[RtoR_index, 'Age'] + 1\n        \n        \n        # Append the S, I, and R arrays\n        S=np.append(S,len(np.where(df.State=='S')[0]))\n        I=np.append(I,len(np.where(df.State=='I')[0]))\n        R=np.append(R,len(np.where(df.State=='R')[0]))\n\n        # Code below for control measures to reduce beta values\n        if control == 1:\n          if (I[-1]/p &gt; 0.015):\n            art1 = 1\n            if over == 0:\n              over = j\n          \n          if art1 == 1:\n            if j &gt; over + 15:    \n            #if Ipd[-2] &gt; Ipd[-1]:\n              art2 = 1\n\n          if over != 0:\n            #b = beta2+(b1/np.exp((j+3-over)/15))\n            b = beta2+(b1/np.exp((j+1-over)/10))\n\n        if control == 2:\n          if (I[-1]/p &gt; 0.3):\n            art1 = 1\n            if over == 0:\n              over = j\n              #print(over)\n          \n          if art1 == 1:\n            if j &gt; over + 15:    \n            #if Ipd[-2] &gt; Ipd[-1]:\n              art2 = 1\n\n          if over != 0:\n            #b = beta2+(b1/np.exp((j+3-over)/15))\n            b = beta2+(b1/np.exp((j+1-over)/10))\n\n\n        xxbeta2 = ((S[j-1]+I[j-1])/I[j-1])*Ipd[j]/S[j-1]\n        #xxbeta2 = 0.5\n        #print(xxbeta2)\n        b2 = np.append(b2, xxbeta2)\n                \n    #Epd[0]+=num_E\n    Ipd[0]+=num_I\n    Rpd[0]+=num_R\n\n    #return S,E,I,R, Epd, Ipd, Rpd, xxbeta\n    return S, I, R, Spd, Ipd, Rpd, xxbeta, b2, over"
  },
  {
    "objectID": "posts/2021-05-07-stochastic_HIV_model/2021-05-07-stochastic_HIV_model.html#testing-the-model",
    "href": "posts/2021-05-07-stochastic_HIV_model/2021-05-07-stochastic_HIV_model.html#testing-the-model",
    "title": "HIV modeling",
    "section": "Testing the model",
    "text": "Testing the model\n\n#collapse_hide\n# Define parameters for stochastic model\ndays = 200\np = 10000\nnum_E = 0\nnum_I = 1\nnum_R = 0\nbeta_stoch = 0.3*np.ones(days)\nbeta_stoch2 = 0.05\n\n# Run 3 stochastic simulations\nresults_stoch1 = seir_model_stoch(beta_stoch,beta_stoch2, p, num_I, num_R, years, 'gamma', 0, 1)\nresults_stoch2 = seir_model_stoch(beta_stoch, beta_stoch2, p, num_I, num_R, years, 'gamma', 0, 1)\nresults_stoch3 = seir_model_stoch(beta_stoch, beta_stoch2, p, num_I, num_R, years, 'gamma', 0, 2)\nresults_stoch4 = seir_model_stoch(beta_stoch, beta_stoch2, p, num_I, num_R, years, 'gamma', 0, 2)\n\n\nresults_stoch1[8]\n\n26\n\n\n\n#collapse_hide\nfig = go.Figure(data=[    \n    go.Scatter(name='Beta_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[6], line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='Beta_meas1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[7], line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='I_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[1]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch1\"),\n    go.Bar(name='Ip_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[4]*10/p, legendgroup=\"stoch1\"),\n    go.Scatter(name='R_stoch1', x=np.arange(len(results_stoch1[0])), y=results_stoch1[2]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch1\"),\n    go.Scatter(name='Beta_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[6], line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='Beta_meas2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[7], line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='I_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[1]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch2\"),\n    go.Bar(name='Ip_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[4]*10/p, legendgroup=\"stoch2\"),\n    go.Scatter(name='R_stoch2', x=np.arange(len(results_stoch2[0])), y=results_stoch2[2]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch2\"),\n    go.Scatter(name='Beta_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[6], line={'dash':'dot', 'color':'yellow'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='Beta_meas3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[7], line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='I_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[1]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch3\"),\n    go.Bar(name='Ip_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[4]*10/p, legendgroup=\"stoch3\"),\n    go.Scatter(name='R_stoch3', x=np.arange(len(results_stoch3[0])), y=results_stoch3[2]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='Beta_stoch4', x=np.arange(len(results_stoch4[0])), y=results_stoch4[6], line={'dash':'dot', 'color':'yellow'}, legendgroup=\"stoch4\"),\n    go.Scatter(name='Beta_meas4', x=np.arange(len(results_stoch4[0])), y=results_stoch4[7], line={'dash':'dot','color':'yellow'}, legendgroup=\"stoch4\"),\n    go.Scatter(name='I_stoch4', x=np.arange(len(results_stoch4[0])), y=results_stoch4[1]/p, line={'dash':'dot', 'color':'red'}, legendgroup=\"stoch4\"),\n    go.Bar(name='Ip_stoch4', x=np.arange(len(results_stoch4[0])), y=results_stoch4[4]*10/p, legendgroup=\"stoch4\"),\n    go.Scatter(name='R_stoch4', x=np.arange(len(results_stoch4[0])), y=results_stoch4[2]/p, line={'dash':'dot', 'color':'green'}, legendgroup=\"stoch4\")\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of stochasticity on Deterministic SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#motivation-for-write-up",
    "href": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 5",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 5th part of a multi-part series blog post on modeling in epidemiology.\nThe COVID-19 pandemic has brought a lot of attention to the study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on two key points.\nThe 1st part of the blog series showed an epidemic could occur when \\(R_0 &gt; 1\\) and that it was fully characerized by the average \\(\\beta\\) and the average \\(T_{Infectious}\\).\nWe have also seen that the higher \\(R_0\\), the faster and the higher the peak infectious will be.\nThe latest blog post however showed the importance of the distribution of \\(T_{Infectious}\\) to simulate the SEIR model and how it impacted the spread of the disease and the peak of infectious individuals. Even with lower \\(R_0\\) values, the infectious peak were higher when using Gamma or Weibull distributions for \\(T_{Infectious}\\).\nThis 5th installment examines this discrepancy further.\n\n\nCode\nimport pandas as pd\nimport numpy as np\nimport math\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\nfrom numpy.random import default_rng\nrng = default_rng()\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\n# Let's build a numerical solution\ndef seir_model(init, parms, days):\n    S_0, E_0, I_0, R_0 = init\n    Epd, Ipd, Rpd = [0], [0], [0]\n    S, E, I, R = [S_0], [E_0], [I_0], [R_0]\n    dt=0.1\n    t = np.linspace(0,days,int(days/dt))\n    sigma, beta, gam = parms\n    for _ in t[1:]:\n        next_S = S[-1] - beta*S[-1]*I[-1]*dt\n        Epd.append(beta*S[-1]*I[-1]*dt)\n        next_E = E[-1] + (beta*S[-1]*I[-1] - sigma*E[-1])*dt\n        Ipd.append(sigma*E[-1]*dt)\n        next_I = I[-1] + (sigma*E[-1] - gam*I[-1])*dt\n        Rpd.append(gam*I[-1]*dt)\n        next_R = R[-1] + (gam*I[-1])*dt\n        S.append(next_S)\n        E.append(next_E)\n        I.append(next_I)\n        R.append(next_R)\n    return np.stack([S, E, I, R, Epd, Ipd, Rpd]).T\n\n\n\n\n\n\n\nCode\n# Need this new function for model below:\ndef make_df(p,num_E, num_I, num_R):\n  df = pd.DataFrame(np.full((p,1), 'S').T[0], columns=['State'])\n  df['Day'] = 0\n  tochange=df.loc[rng.choice(p, size=num_E+num_I+num_R, replace=False),'State'].index\n  df.loc[tochange[0:num_E],'State'] = 'E'\n  df.loc[tochange[num_E:num_I+num_E],'State'] = 'I'\n  df.loc[tochange[num_E+num_I:num_E+num_I+num_R],'State'] = 'R'\n  return df\n\n\n\n\nCode\ndef seir_model_stoch(beta, p, num_E, num_I, num_R, days, T_Latent, T_Infectious):\n\n    # Initialize population dataframe with data given by user\n    df = make_df(p,num_E, num_I, num_R)\n    \n    # This variable is used to track daily value of beta if it varies over time\n    xxbeta=np.array([],dtype=float)\n\n    # Initialize the arrays to return\n    # Below are numbers of S, E, I, R total\n    S=np.array([],dtype=int)\n    E=np.array([],dtype=int)\n    I=np.array([],dtype=int)\n    R=np.array([],dtype=int)\n    # Below are the daily additions in S, E, I, R\n    Spd=np.array([],dtype=int)\n    Epd=np.array([],dtype=int)\n    Ipd=np.array([],dtype=int)\n    Rpd=np.array([],dtype=int)\n\n    b=beta\n    \n    # Stochastic model so use random values to decide on progression\n    rand = np.random.random(size=(p,days))\n\n    # Depending if you want exponential or gamma distribution for T_Latent\n    if T_Latent == 'expon':\n      EtoI = expon.rvs(loc=0,scale=5.2,size=p)\n    else:\n      EtoI = gamma.rvs(1.8,loc=0.9,scale=(5.2-1.8)/0.9,size=p)\n\n    # Depending if you want exponential, gamma, or Weibull distribution for T_Infectious\n    # Uses distributions found on blog part 3\n    if T_Infectious == 'expon':\n      ItoR = expon.rvs(loc=0,scale=28.85,size=p)\n    elif T_Infectious == 'gamma':\n      ItoR = gamma.rvs(4,loc=3,scale=4.25,size=p)    \n    else:\n      ItoR = weibull_min.rvs(2.3, loc=2, scale=20.11, size=p)\n\n    # Iterate over every day the simulation is run\n    for j in range(0,days-1):\n\n        # Record daily beta values\n        xxbeta=np.append(beta, b)\n\n        # First we get the index of the individuals that will change state today:\n\n        # Random number tells you which 'S' have been exposed on this day \n        StoE_index = df.loc[(df.State == 'S') & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/p)].index\n\n        # For each row, if a person has been a certain number of days in E, they will go to I\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        EtoI_index = df.loc[(df.State == 'E') & (j-df.Day &gt;= EtoI)].index\n        \n        # Similaraly as above\n        # For each row, if a person has been a certain number of days in I, they will go to R\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        ItoR_index = df.loc[(df.State == 'I') & (j-df.Day &gt;= ItoR)].index\n\n        # Use indexes collected above to populate per day values\n        Epd = np.append(Epd,len(StoE_index))\n        Ipd = np.append(Ipd,len(EtoI_index))\n        Rpd = np.append(Rpd,len(ItoR_index))\n\n        # Now we use the indexes collected above randomly to change the actual population dataframe to the new states\n        df.loc[ItoR_index, 'State'] = 'R'\n        df.loc[EtoI_index, 'State'] = 'I'\n        df.loc[StoE_index, 'State'] = 'E'\n        df.loc[ItoR_index, 'Day'] = j\n        df.loc[EtoI_index, 'Day'] = j\n        df.loc[StoE_index, 'Day'] = j\n        df.loc[ItoR_index, 'DayR'] = j\n        df.loc[EtoI_index, 'DayI'] = j\n        df.loc[StoE_index, 'DayE'] = j\n        \n        # Append the S, E, I, and R arrays\n        S=np.append(S,len(np.where(df.State=='S')[0]))\n        E=np.append(E,len(np.where(df.State=='E')[0]))\n        I=np.append(I,len(np.where(df.State=='I')[0]))\n        R=np.append(R,len(np.where(df.State=='R')[0]))\n\n        # Code below for control measures to reduce beta values\n#        if ((I[-1] &gt; 1000) & (Ipd[-1] &gt; 399)): \n#            b = beta2\n#        elif ((I[-1] &gt; 1000) & (Ipd[-1] &lt; 400)): \n#            b = beta3\n                \n    Epd[0]+=num_E\n    Ipd[0]+=num_I\n    Rpd[0]+=num_R\n\n    return S,E,I,R, Epd, Ipd, Rpd, xxbeta, df"
  },
  {
    "objectID": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#peak-of-infectious-individuals",
    "href": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#peak-of-infectious-individuals",
    "title": "Epidemic modeling - Part 5",
    "section": "Peak of infectious individuals",
    "text": "Peak of infectious individuals\nLet’s first try to characterize when the peak of infectious indiviuals occurs in the SEIR model.\nThe peak of infectious individuals occurs when the number of individuals that recover per day (\\(R_{pd}\\)) becomes greater than the number of new infectious individuals per day (\\(I_{pd}\\)), i.e. when:\n\\[R_{pd} \\geq I_{pd}\\]\n\nConvolution and daily numbers\nMathematical derivation of \\(I_{pd}\\):\nIn the stochastic model, the number of new infectious individuals per day is the sum of the daily new exposures per day of the previous days multiplied by the probability that they become infectious after so many days.\nWe write:\n\\[I_{pd}[j] = \\sum_{n_L=0}^{M_L-1}h_L[n_L]~E_{pd}[j-n_L]\\]\nMathematically, this means \\(I_{pd}[j]\\) is the result of convolution of \\(E_{pd}\\) and an impulse response \\(h_L[n]\\) where \\(h_L[n]\\) describes the distribution of \\(T_{Latent}\\), and we can write:\n\\[I_{pd}[j] = h_L[j]\\circledast E_{pd}[j]\\]\nFrom this derivation, we can see the \\(I_{pd}\\) depends on the distribution of \\(T_{Latent}\\) and \\(E_{pd}\\) (the number of new exposures per day) of the previous days.\nWhen initial conditions are the same, this means \\(T_{Infectious}\\) has no impact on \\(I_{pd}\\) and so the rate of new infectious individuals will look the same between the two models (exponential or gamma distributed \\(T_{Infectious}\\)).\nMathematical derivation of \\(R_{pd}\\):\nWe can similarly describe \\(R_{pd}[j]\\) as the result of convolution of \\(I_{pd}\\) and an impulse response \\(h_I[n]\\) where \\(h_I[n]\\) describes the distribution of \\(T_{Infectious}\\).\nIn other words:\n\\[R_{pd}[j] = \\sum_{n_I=0}^{M_I-1}h_I[n_I]~I_{pd}[j-n_I] = h_I[j]\\circledast I_{pd}[j]\\]\n\n\nWhen does the peak occur?\nIt occurs on day j where the threshold below is reached:\n\\[R_{pd}[j] = I_{pd}[j]\\] \\[\\leftrightarrow \\sum_{n_I=0}^{M_I-1}h_I[n_I]~I_{pd}[j-n_I] = \\sum_{n_L=0}^{M_L-1}h_L[n_L]~E_{pd}[j-n_L]\\]\nWhile this is complicated to solve analytically, we can look at the distribution of \\(T_{Infectious}\\) and get some clues as to what might happen with different distributions."
  },
  {
    "objectID": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#i_pd-and-r_pd-for-t_infectious-sim-explambda-vs.-t_infectious-sim-weibulllambda-kgamma",
    "href": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#i_pd-and-r_pd-for-t_infectious-sim-explambda-vs.-t_infectious-sim-weibulllambda-kgamma",
    "title": "Epidemic modeling - Part 5",
    "section": "\\(I_{pd}\\) and \\(R_{pd}\\) for \\(T_{Infectious} \\sim Exp(\\lambda)\\) vs. \\(T_{Infectious} \\sim Weibull(\\lambda, k,\\gamma)\\)",
    "text": "\\(I_{pd}\\) and \\(R_{pd}\\) for \\(T_{Infectious} \\sim Exp(\\lambda)\\) vs. \\(T_{Infectious} \\sim Weibull(\\lambda, k,\\gamma)\\)\n\n\\(T_{Infectious} \\sim Exp(28.85)\\) vs. \\(T_{Infectious} \\sim Weibull(2.3, 20.11, 2)\\)\nLet’s first have another look at the difference between these two distributions:\n\n\nCode\nlocw=2\nwk = 2.3\nwl = (20-locw)/(math.log(2)**(1/wk))\n\nloce=0\nscalee=28.85-loce\n\np=10000\n\ndf = pd.DataFrame({\n    'Exponential': expon.rvs(loc=loce, scale=scalee,size=p),\n    'Weibull': weibull_min.rvs(wk, loc=locw, scale=wl,size=p)\n    })\n\nfig = px.histogram(df.stack().reset_index().rename(columns={\"level_1\": \"Distribution\"}), x=0, color=\"Distribution\", marginal='box')\nfig.update_layout(\n    title={\n        'text':'Exponential vs. Weibull distributions',\n        'x':0.5,\n        'xanchor':'center'\n    },\n    barmode='overlay',\n    xaxis_title='Days',\n    yaxis_title='Count',\n    legend=dict(\n        x=1,\n        y=0,\n        traceorder=\"normal\",\n    )\n)\nfig.show()\n\n\n\n                                                \n\n\n\n\nImpact on \\(I_{pd}\\) \\(R_{pd}\\):\nLet’s see how the two distributions of \\(T_{Infectious}\\) result in different curbs for \\(I_{pd}\\) and \\(R_{pd}\\).\n\n\nCode\n# Define parameters for stochastic model\ndays = 200\np = 10000\nnum_E = 1\nnum_I = 0\nnum_R = 0\nbeta_stoch = 0.5*np.ones(days)\n\n# Run 2 stochastic simulations, 1 with exponential gamma, 1 with weibull gamma\nresults_stoch0 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 'expon')\nresults_stoch1 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days, 1, 1)\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Ipd_Exp', x=np.arange(len(results_stoch0[0])), y=results_stoch0[5], line={'dash':'dashdot', 'color':'red'}, legendgroup=\"stoch4\"),\n    go.Scatter(name='Rpd_Exp', x=np.arange(len(results_stoch0[0])), y=results_stoch0[6], line={'dash':'dashdot', 'color':'green'}, legendgroup=\"stoch4\"),\n    go.Scatter(name='Ipd_Weibull', x=np.arange(len(results_stoch1[0])), y=results_stoch1[5], line={'dash':'solid', 'color':'red'}, legendgroup=\"stoch3\"),\n    go.Scatter(name='Rpd_Weibull', x=np.arange(len(results_stoch1[0])), y=results_stoch1[6], line={'dash':'solid', 'color':'green'}, legendgroup=\"stoch3\")\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Effect of Exponential vs. Weibull distributed } T_{Infectious} \\text{ on } I_{pd} \\text{ and } R_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\n\n\nAnalysis:\nAs discussed above, we can see here \\(I_{pd}\\) are very similar between the two models.\nHowever, there are two key takeaways from these graphs:\n\nRise of total infectious individuals:\n\nThe Exponential distribution leads to more recoveries early on as the \\(R_{pd}\\) for the Exp distribution leads the \\(R_{pd}\\) of the Weibull distribution by ~6 days in the earl recovery period.\nIntuitively, we can thus understand that total infectious people will increase slower with the Eponential distribution than the Weibull distribution (since more people recover faster in the Exp model), and so the peak of infectious individuals will be earlier with the Weibull distribution.\n\nRecoveries:\n\nWhile the peak appears faster with a Weibull distribution, we also see that after the initial delay, the Weibull distribution leads to larger number of recoveries and so the total number of infectious individuals will tend to 0 much quicker than with the Exp distribution."
  },
  {
    "objectID": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#discussion",
    "href": "posts/2020-04-01-diagnosing-R0-and-peak-infectious/2020-04-01-diagnosing-R0-and-peak-infectious.html#discussion",
    "title": "Epidemic modeling - Part 5",
    "section": "Discussion",
    "text": "Discussion\nWhile \\(R_0\\) seemed to be a good measure of the spread of disease and a good predictor of the peak of infectious individuals in a population, we find here that the actual distribution of \\(T_{Infectious}\\) plays a crucial role in detemining the dynamics of the SEIR model.\nThat is to say that while estimating \\(R_0\\) is important in times of epidemics or pandemics, finding the actual distributions of \\(T_{Latent}\\) and \\(T_{Infetious}\\) are equally important in predicting the impact of the disease."
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html",
    "title": "Epidemic modeling - Part 7",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport numpy as np\n\nimport math\n\nfrom scipy import signal\n\nimport plotly.graph_objects as go\nimport plotly.express as px\n\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\n\nfrom numpy.random import default_rng\nrng = default_rng()\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\n\n# Let's build a numerical solution\ndef seir_model(init, parms, days):\n    S_0, E_0, I_0, R_0 = init\n    Epd, Ipd, Rpd = [0], [0], [0]\n    S, E, I, R = [S_0], [E_0], [I_0], [R_0]\n    dt=0.1\n    t = np.linspace(0,days,int(days/dt))\n    sigma, beta, gam = parms\n    for _ in t[1:]:\n        next_S = S[-1] - beta*S[-1]*I[-1]*dt\n        Epd.append(beta*S[-1]*I[-1]*dt)\n        next_E = E[-1] + (beta*S[-1]*I[-1] - sigma*E[-1])*dt\n        Ipd.append(sigma*E[-1]*dt)\n        next_I = I[-1] + (sigma*E[-1] - gam*I[-1])*dt\n        Rpd.append(gam*I[-1]*dt)\n        next_R = R[-1] + (gam*I[-1])*dt\n        S.append(next_S)\n        E.append(next_E)\n        I.append(next_I)\n        R.append(next_R)\n    return np.stack([S, E, I, R, Epd, Ipd, Rpd]).T\nCode\n# Need this new function for model below:\ndef make_df(p,num_E, num_I, num_R):\n  df = pd.DataFrame(np.full((p,1), 'S').T[0], columns=['State'])\n  df['Day'] = 0\n  tochange=df.loc[rng.choice(p, size=num_E+num_I+num_R, replace=False),'State'].index\n  df.loc[tochange[0:num_E],'State'] = 'E'\n  df.loc[tochange[num_E:num_I+num_E],'State'] = 'I'\n  df.loc[tochange[num_E+num_I:num_E+num_I+num_R],'State'] = 'R'\n  return df\nCode\ndef seir_model_stoch(beta, p, num_E, num_I, num_R, days):\n\n    # Initialize population dataframe with data given by user\n    df = make_df(p,num_E, num_I, num_R)\n    \n    # This variable is used to track daily value of beta if it varies over time\n    xxbeta=np.array([],dtype=float)\n\n    # Initialize the arrays to return\n    # Below are numbers of S, E, I, R total\n    S=np.array([],dtype=int)\n    E=np.array([],dtype=int)\n    I=np.array([],dtype=int)\n    R=np.array([],dtype=int)\n    # Below are the daily additions in S, E, I, R\n    Spd=np.array([],dtype=int)\n    Epd=np.array([],dtype=int)\n    Ipd=np.array([],dtype=int)\n    Rpd=np.array([],dtype=int)\n\n    b=beta\n    \n    # Stochastic model so use random values to decide on progression\n    rand = np.random.random(size=(p,days))\n\n    # Depending if you want exponential or gamma distribution for T_Latent\n    EtoI = gamma.rvs(1.8,loc=0.9,scale=(5.2-1.8)/0.9,size=p)\n\n    # Depending if you want exponential, gamma, or Weibull distribution for T_Infectious\n    # Uses distributions found on blog part 3\n    ItoR = weibull_min.rvs(2.3, loc=2, scale=20.11, size=p)\n\n    # Iterate over every day the simulation is run\n    for j in range(0,days-1):\n\n        # Record daily beta values\n        xxbeta=np.append(beta, b)\n\n        # First we get the index of the individuals that will change state today:\n\n        # Random number tells you which 'S' have been exposed on this day \n        StoE_index = df.loc[(df.State == 'S') & (rand[:,j] &lt; b[j]*len(np.where(df.State=='I')[0])/p)].index\n\n        # For each row, if a person has been a certain number of days in E, they will go to I\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        EtoI_index = df.loc[(df.State == 'E') & (j-df.Day &gt;= EtoI)].index\n        \n        # Similaraly as above\n        # For each row, if a person has been a certain number of days in I, they will go to R\n        # This follows EtoI variable which is either exponential or gamma distributed according to above\n        ItoR_index = df.loc[(df.State == 'I') & (j-df.Day &gt;= ItoR)].index\n\n        # Use indexes collected above to populate per day values\n        Epd = np.append(Epd,len(StoE_index))\n        Ipd = np.append(Ipd,len(EtoI_index))\n        Rpd = np.append(Rpd,len(ItoR_index))\n\n        # Now we use the indexes collected above randomly to change the actual population dataframe to the new states\n        df.loc[ItoR_index, 'State'] = 'R'\n        df.loc[EtoI_index, 'State'] = 'I'\n        df.loc[StoE_index, 'State'] = 'E'\n        df.loc[ItoR_index, 'Day'] = j\n        df.loc[EtoI_index, 'Day'] = j\n        df.loc[StoE_index, 'Day'] = j\n        df.loc[ItoR_index, 'DayR'] = j\n        df.loc[EtoI_index, 'DayI'] = j\n        df.loc[StoE_index, 'DayE'] = j\n        \n        # Append the S, E, I, and R arrays\n        S=np.append(S,len(np.where(df.State=='S')[0]))\n        E=np.append(E,len(np.where(df.State=='E')[0]))\n        I=np.append(I,len(np.where(df.State=='I')[0]))\n        R=np.append(R,len(np.where(df.State=='R')[0]))\n\n        # Code below for control measures to reduce beta values\n#        if ((I[-1] &gt; 1000) & (Ipd[-1] &gt; 399)): \n#            b = beta2\n#        elif ((I[-1] &gt; 1000) & (Ipd[-1] &lt; 400)): \n#            b = beta3\n                \n    Epd[0]+=num_E\n    Ipd[0]+=num_I\n    Rpd[0]+=num_R\n\n    return S,E,I,R, Epd, Ipd, Rpd, xxbeta, df"
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html#motivation-for-write-up",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 7",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 7th part of a multi-part series blog post on modeling in epidemiology.\nThe goal of this 7th installment is to expand on the notions seen in part 5.\nMost notably, the idea is to expand on the notion of convolution and deconvolution and to see how it can be useful to describe an epidemic."
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html#available-data",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html#available-data",
    "title": "Epidemic modeling - Part 7",
    "section": "Available data",
    "text": "Available data\nIf you look at the the COVID-19 trackers around the web, or even mine, you can get a sense of what data is available for study.\nGenerally speaking we have the following:\n\nTotal number of positive individuals\nDaily number of newly diagnosed individuals\nDaily number of recovered individuals\nDaily number of deaths\n\nResearch has also shown some vague numbers on both \\(T_{Latent}\\) and \\(T_{Infectious}\\).\nAbout the data:\n\nWe don’t have data for exposure - how can we get it using deconvolution ??\nThe data for some regions can be very sparse"
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html#convolution",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html#convolution",
    "title": "Epidemic modeling - Part 7",
    "section": "Convolution",
    "text": "Convolution\n\nConvolution to get \\(I_{pd}\\)\nWe have seen that daily new infectious individuals is given by:\n\\[I_{pd}[j] = \\sum_{n_L=0}^{M_L-1}h_L[n_L]~E_{pd}[j-n_L]= h_L[j]\\circledast E_{pd}[j]\\]\nWhere \\(h_L[j]\\) describes the distribution of \\(T_{Latent}\\).\n\n\nConvolution to get \\(R_{pd}\\)\nSimilarly, we have seen that daily new recovered individuals (deaths + recoveries in fact) is given by:\n\\[R_{pd}[j] = \\sum_{n_I=0}^{M_I-1}h_I[n_I]~I_{pd}[j-n_I]= h_I[j]\\circledast I_{pd}[j]\\]\nWhere \\(h_I[j]\\) describes the distribution of \\(T_{Infectious}\\)."
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html#finding-h_lj-and-h_ij",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html#finding-h_lj-and-h_ij",
    "title": "Epidemic modeling - Part 7",
    "section": "Finding \\(h_L[j]\\) and \\(h_I[j]\\)",
    "text": "Finding \\(h_L[j]\\) and \\(h_I[j]\\)\n\n\\(h_L[j]\\) is simply the probability of an individual having a latent period of j days\n\\(h_I[j]\\) is similarly the probability of an individual having an infectious period of j days\n\n\n\nCode\ndays = np.arange(100)\ncdf = pd.DataFrame({\n    'T_Latent': gamma.cdf(days, 1.8,loc=0.9,scale=(5.2-1.8)/0.9), \n    'T_Infectious': weibull_min.cdf(days, 2.3,loc=2,scale=20.11)\n    })\nh_L = cdf.diff().T_Latent\nh_I = cdf.diff().T_Infectious\nh_L[0] = 0\nh_I[0] = 0"
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html#convolution-in-practice",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html#convolution-in-practice",
    "title": "Epidemic modeling - Part 7",
    "section": "Convolution in practice",
    "text": "Convolution in practice\n\nComparing \\(I_{pd}\\) from the model to \\(I_{pd}\\) obtained by convolving \\(R_{pd}\\)\nFirst run the SEIR model to obtain the actual \\(I_{pd}\\):\n\n\nCode\n# Define parameters for stochastic model\ndays = 300\np = 10000\nnum_E = 1\nnum_I = 0\nnum_R = 0\nbeta_stoch = 0.5*np.ones(days)\n\n# Run 2 stochastic simulations\nresults_stoch0 = seir_model_stoch(beta_stoch, p, num_E, num_I, num_R, days)\n\n\nNow obtain \\(h_L[j]\\circledast E_{pd}[j]\\):\n\n\nCode\nIpd=signal.fftconvolve(h_L, results_stoch0[4], mode='full')\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Ipd_Actual', x=np.arange(len(results_stoch0[5])), y=results_stoch0[5]),\n    go.Scatter(name='Ipd_convolved', x=np.arange(len(Ipd)), y=Ipd)\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Actual } I_{pd} \\text{ vs. } h_L[j]\\circledast E_{pd}[j]$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\n\n\nComparing \\(R_{pd}\\) from the model to \\(R_{pd}\\) obtained by convolving \\(I_{pd}\\)\nWe can use the actual \\(R_{pd}\\) from the SEIR model above.\nNow obtain \\(h_I[j]\\circledast I_{pd}[j]\\):\n\n\nCode\nRpd=signal.fftconvolve(h_I, results_stoch0[5], mode='full')\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Rpd_Actual', x=np.arange(len(results_stoch0[6])), y=results_stoch0[6]),\n    go.Scatter(name='Rpd_convolved', x=np.arange(len(Rpd)), y=Rpd)\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Actual } R_{pd} \\text{ vs. } h_I[j]\\circledast I_{pd}[j]$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html#de-convolution",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html#de-convolution",
    "title": "Epidemic modeling - Part 7",
    "section": "De-convolution",
    "text": "De-convolution\nWe get very close matches when convlving, can we obtain similar results by deconvolving?\n\nProblems with de-convolution\nIlll-posed\nUnfortunately de-convolution is not as straightforward as the convolution.\nA quick recap of the math, in the frequency domain we have (Fourier or z transform)\n\\[F \\{ f ∗ g \\} = F \\{ f \\} ~ F \\{ g \\}\\]\nAnd so if we have:\n\\[y=\\ f ∗ g\\]\nThen:\n\\[F \\{ y \\} = F \\{ f \\} ~ F \\{ g \\}\\]\nAnd:\n\\[g = F^{-1} \\left(\\frac{F\\{y\\}}{F\\{f\\}} \\right) \\]\nBut this last equation is often ill-posed.\nNoise in data\nWe can see above that daily new data varies a lot from day to day due to the stochasticity of the model. This results in high-frequency decomposition in the frequency domain.\nInitial conditions and boundary-value problems\nBoundary values refer to the values on day 0 and the last day we have data for. Due to the way data is reported on JHU, we someimes have crayz values here, most commonly a value of 0 for the latest day if the data isn0t reported on time for example. These gaps can create issues for deconvolution.\nIn the next blog post I go around this by simplz averaging the last 3 days instead of using only the last day.\n\n\nSolutions to these problems\n\nIterative deconvoluton\nMultiple iterative deconvolution algorithms exist: Lucy_Richardson, Gold, or Van Cittert among others.\nLR has already been used to get daily incidence of the Spanish flu based on death records in Philadelphia at the time for example 1.\nAn adaptation of those above is used here with the basics below (see code for details):\nLet’s use the equation for \\(I_{pd}\\) as an example:\n\\[I_{pd}[j] = \\sum_{n_L=0}^{M_L-1}h_L[n_L]~E_{pd}[j-n_L]= h_L[j]\\circledast E_{pd}[j]\\]\nThe idea is that after an initial guess for \\(E_{pd}\\) we can iteraively find a better one.\nWith the \\(n^{th}\\) guess for \\(E_{pd}\\) written as \\(E_{pd, n}\\) we have:\n\\[I_{pd}[j]= h_L[j]\\circledast E_{pd, n}[j]\\] \\[\\leftrightarrow 0 = I_{pd}[j] - h_L[j]\\circledast E_{pd, n}[j]\\] \\[\\leftrightarrow E_{pd,n+1} = E_{pd,n} + I_{pd}[j] - h_L[j]\\circledast E_{pd, n}[j]\\]\nWhere \\(O[j] = I_{pd}[j] - h_L[j]\\circledast E_{pd, n}[j]\\) is the error term.\nHence we want to minimze O[j].\nInitial guess\nWe know our \\(h_L\\) and \\(h_I\\) are in part simply delay functions, so an initial first guess is to simply use the same signal delayed by the time difference caused by the impulse response.\n\n\nLow-pass filter\nTo go around those high-frequency notes in the data, we can siply use a lowpass filter implemented as a butterworth filter below:\nThe basic effect is that it smoothes the daily values as we have when convolving from the previous state daily values.\n\n\nCode\ndef lowpass(x, fc=0.05):\n  fs = 1  # Sampling frequency\n  t = np.arange(len(x)) #select number of days done in SEIR model\n  signala = x\n\n  #fc = 0.05  # Cut-off frequency of the filter\n  w = fc / (fs / 2) # Normalize the frequency\n  b, a = signal.butter(5, w, 'low')\n  return signal.filtfilt(b, a, signala)"
  },
  {
    "objectID": "posts/2020-04-02-convolution/2020-04-02-convolution.html#deconvolution-in-practice",
    "href": "posts/2020-04-02-convolution/2020-04-02-convolution.html#deconvolution-in-practice",
    "title": "Epidemic modeling - Part 7",
    "section": "Deconvolution in practice",
    "text": "Deconvolution in practice\n\nCoding the iterative deconvolution\n\n\nCode\n# Let's define an iteration function:\ndef iter_deconv(alpha, impulse_response, input_signal, delay, comparator):\n  conv=signal.fftconvolve(impulse_response, input_signal, mode='full')\n  correction=np.roll(comparator-conv[:len(comparator)], delay)\n  input_signal=np.floor(lowpass(alpha*correction+input_signal))\n  input_signal[input_signal&lt;0]=0\n  return input_signal\n\n# Define a function to return MSE between two signals as a measure of goodness of fit\ndef msecalc(A, B):\n  return ((A - B)**2).mean(axis=0)\n\n\n\n\nComparing \\(E_{pd}\\) from the model to \\(E_{pd}\\) obtained by de-convolving \\(I_{pd}\\)\n\n\nCode\n#regularization parameter\nalpha=2\n\n# Setup up the resultant Ipd we want to compare our guess with\nIpd=np.floor(lowpass(results_stoch0[5]))\nIpd[Ipd&lt;0]=0\n\n# Find delay caused by h_L\ndelay=Ipd.argmax()-signal.fftconvolve(Ipd, h_L, mode='full').argmax()\n\n# We want initial guess to simply be the result of the convolution delayed\ninitial_guess=np.roll(Ipd,delay)\nEnext = initial_guess\n\n# AN array to record MSE between result we want and our iterated guess\nmse=np.array([])\nmse=np.append(mse, 100000)\nmse=np.append(mse, msecalc(Ipd, signal.fftconvolve(h_L, Enext, mode='full')[:len(Ipd)]))\n\nitercount=0\nwhile mse[-1] &lt; mse[-2]:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  mse=np.append(mse, msecalc(Ipd, signal.fftconvolve(h_L, Enext, mode='full')[:len(Ipd)]))\n  print(\"Iteration #\" + str(itercount) +\": MSE= \"+str(mse[itercount]))\nprint(\"Iteration #\" + str(itercount+1) +\": MSE= \"+str(mse[-1])+\" so we use the result of the previous iteration.\")\n\n\nIteration #1: MSE= 130.07201423939554\nIteration #2: MSE= 28.985923141326676\nIteration #3: MSE= 21.14637589704021\nIteration #4: MSE= 15.712400523386\nIteration #5: MSE= 12.376728037642959\nIteration #6: MSE= 10.371422096439822\nIteration #7: MSE= 7.807135996773338\nIteration #8: MSE= 7.115442105152689\nIteration #9: MSE= 5.243210227637416\nIteration #10: MSE= 4.887916535313005\nIteration #11: MSE= 3.789243188684947\nIteration #12: MSE= 3.6143739648770974\nIteration #13: MSE= 2.857605866687358\nIteration #14: MSE= 2.8116375311783885\nIteration #15: MSE= 2.376734514666326\nIteration #16: MSE= 2.423265713368301 so we use the result of the previous iteration.\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='E_pd', x=np.arange(150), y=results_stoch0[4]),\n    go.Scatter(name='Epd=lowpass(E_pd)', x=np.arange(150), y=lowpass(results_stoch0[4])),\n    go.Scatter(name='Epd=deconv(I_pd)', x=np.arange(150), y=Enext),\n    go.Scatter(name='I_pd', x=np.arange(150), y=results_stoch0[5]),\n    go.Scatter(name='Ipd=lowpass(I_pd)', x=np.arange(150), y=lowpass(results_stoch0[5])),\n    go.Scatter(name='Ipd=conv(E_pd)', x=np.arange(150), y=signal.fftconvolve(h_L, lowpass(results_stoch0[4]), mode='full')),\n    go.Scatter(name='Ipd=conv(deconv(Ipd))', x=np.arange(150), y=signal.fftconvolve(h_L, Enext, mode='full')[:len(Ipd)])\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Actual } E_{pd} \\text{ vs. deconvolution of } I_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nThe iterative deconvolution seems to work nicely and we get close results.\n\n\nComparing \\(I_{pd}\\) from the model to \\(I_{pd}\\) obtained by de-convolving \\(R_{pd}\\)\nLet’s try the same thing but using \\(R_{pd}\\) to get \\(I_{pd}\\):\n\n\nCode\n#regularization parameter\nalpha=2\n\n# Setup up the resultant Ipd we want to compare our guess with\nRpd=np.floor(lowpass(results_stoch0[6]))\nRpd[Rpd&lt;0]=0\n\n# Find delay caused by h_I\ndelay=Rpd.argmax()-signal.fftconvolve(Rpd, h_I, mode='full').argmax()\n\n# We want initial guess to simply be the result of the convolution delayed\ninitial_guess=np.roll(Rpd,delay)\nInext = initial_guess\n\n\n# AN array to record MSE between result we want and our iterated guess\nmse=np.array([])\nmse=np.append(mse, 100000)\nmse=np.append(mse, msecalc(Rpd, signal.fftconvolve(h_I, Inext, mode='full')[:len(Rpd)]))\n\nitercount=0\nwhile mse[-1] &lt; mse[-2]:\n  itercount=itercount+1\n  Inext=iter_deconv(alpha, h_I, Inext, delay, Rpd)\n  mse=np.append(mse, msecalc(Rpd, signal.fftconvolve(h_I, Inext, mode='full')[:len(Rpd)]))\n  print(\"Iteration #\" + str(itercount) +\": MSE= \"+str(mse[itercount]))\nprint(\"Iteration #\" + str(itercount+1) +\": MSE= \"+str(mse[-1])+\" so we use the result of the previous iteration.\")\n\n\nIteration #1: MSE= 183.9549261264147\nIteration #2: MSE= 36.4813973184298\nIteration #3: MSE= 18.45240430779509\nIteration #4: MSE= 11.032242359194717\nIteration #5: MSE= 8.923820246583984\nIteration #6: MSE= 6.676254645792155\nIteration #7: MSE= 5.615808839920469\nIteration #8: MSE= 4.308264204337396\nIteration #9: MSE= 3.682767695460665\nIteration #10: MSE= 2.8722567678200193\nIteration #11: MSE= 2.5674870609908087\nIteration #12: MSE= 2.147294049205842\nIteration #13: MSE= 2.01828193955411\nIteration #14: MSE= 1.702522285527881\nIteration #15: MSE= 1.6490031212266356\nIteration #16: MSE= 1.476551953269413\nIteration #17: MSE= 1.4487934342939142\nIteration #18: MSE= 1.299273631101706\nIteration #19: MSE= 1.2921686217653456\nIteration #20: MSE= 1.184990178055593\nIteration #21: MSE= 1.2016201858482565 so we use the result of the previous iteration.\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Ipd', x=np.arange(150), y=results_stoch0[5]),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=np.arange(150), y=lowpass(results_stoch0[5])),\n    go.Scatter(name='Ipd=deconv(Rpd)', x=np.arange(150), y=Inext),\n    go.Scatter(name='Rpd', x=np.arange(150), y=results_stoch0[6]),\n    go.Scatter(name='Rpd=conv(Inext)', x=np.arange(150), y=signal.fftconvolve(h_I, Inext, mode='full')),\n    go.Scatter(name='Rpd=lowpass(Rpd)', x=np.arange(150), y=lowpass(results_stoch0[6])),\n    go.Scatter(name='Rpd=conv(deconv(Rpd))', x=np.arange(150), y=signal.fftconvolve(h_I, Inext, mode='full')[:len(Rpd)])    \n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Actual } I_{pd} \\text{ vs. deconvolution of } R_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nAgain our algorithm works nicely."
  },
  {
    "objectID": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#motivation-for-write-up",
    "href": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 2",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 2nd part of a multi-part series blog post on modeling in epidemiology.\nThe COVID-19 pandemic has brought a lot of attention to the study of epidemiology and more specifically to the various mathematical models that are used to inform public health policies. Everyone has been trying to understand the growth or slowing of new cases and trying to predict the necessary sanitary resources. This blog post attempts to explain the foundations for some of the most used models and enlighten the reader on two key points.\nAfter introducing the concepts of compartmentalization and disease dynamics in the first blog post, this second part is focused on developing a deterministic numerical solution for the SEIR model discussed there.\nWhile normally the goal is to use real-world data to infer characteristics of the underlying disease (as will be done in later blog posts), here we want to use simulate the spread of a COVID-19 like disease in a population of 10000, and look at the effects of the different parameters on the spread."
  },
  {
    "objectID": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#recall-seir-model-equations",
    "href": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#recall-seir-model-equations",
    "title": "Epidemic modeling - Part 2",
    "section": "Recall SEIR model equations",
    "text": "Recall SEIR model equations\nSee the first blog post for derivation.\n\nContinuous-time:\n\n\\(\\frac{ds(t)}{dt}=-\\beta i(t) s(t)\\)\n\\(\\frac{de(t)}{dt}=\\beta i(t) s(t) - \\sigma e(t)\\)\n\\(\\frac{di(t)}{dt}=\\sigma e(t) - \\gamma i(t)\\)\n\\(\\frac{dr(t)}{dt}=\\gamma i(t)\\)\n\nDiscrete-time:\n\n\\(\\Delta S = -\\beta I S \\Delta T\\)\n\\(\\Delta E = (\\beta I S -\\sigma E) \\Delta T\\)\n\\(\\Delta I = (\\sigma E - \\gamma I) \\Delta T\\)\n\\(\\Delta R = \\gamma I \\Delta T\\)"
  },
  {
    "objectID": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#numerical-solution-to-this-deteministic-population-level-model",
    "href": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#numerical-solution-to-this-deteministic-population-level-model",
    "title": "Epidemic modeling - Part 2",
    "section": "Numerical solution to this deteministic population level model",
    "text": "Numerical solution to this deteministic population level model\n\nCoding the SEIR model\nTo build the SEIR model we simply use the discrete-time set of equations above.\nThe model will thus take as input the following:\n\nInitial proportion of S, E, I, and R in the population\n\\(\\beta\\) parameter pertaining to the population in question\n\\(\\sigma\\) and \\(\\gamma\\) parameters pertaining to the disease\nNumbers of days to run the simulation\n\n\n\nCode\n# Import required libraries\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\n\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\n\n\n\n\n\n\nCode\n# Let's build a numerical solution\n\ndef seir_model(init, parms, days):\n    S_0, E_0, I_0, R_0 = init\n    Epd, Ipd, Rpd = [0], [0], [0]\n    S, E, I, R = [S_0], [E_0], [I_0], [R_0]\n    dt=0.1\n    t = np.linspace(0,days,int(days/dt))\n    sigma, beta, gam = parms\n    for _ in t[1:]:\n        next_S = S[-1] - beta*S[-1]*I[-1]*dt\n        Epd.append(beta*S[-1]*I[-1]*dt)\n        next_E = E[-1] + (beta*S[-1]*I[-1] - sigma*E[-1])*dt\n        Ipd.append(sigma*E[-1]*dt)\n        next_I = I[-1] + (sigma*E[-1] - gam*I[-1])*dt\n        Rpd.append(gam*I[-1]*dt)\n        next_R = R[-1] + (gam*I[-1])*dt\n        S.append(next_S)\n        E.append(next_E)\n        I.append(next_I)\n        R.append(next_R)\n    return np.stack([S, E, I, R, Epd, Ipd, Rpd]).T\n\n\n\n\nCOVID-19 parameters\nSimulation parameters used for plot below:\n\nDays = 100\nPopulation = 10000\nNumber of susceptible people on day 0 = 9999\nNumber of exposed people on day 0 = 1\nNo infected or recovered people on day 0\n\nA lot of research is ongoing into the COVID-19 characteristics of \\(\\beta\\), \\(\\sigma\\), and \\(\\gamma\\).\nHowever, these are complex studies that require a lot of data and so far we have little information to go on.\nThe literature suggests the following:\n\n\\(\\underline{T_{Incubation}}\\):\n\nThe mean is 5-6 days but it can range anywhere from 2-14 days 1 2\nAnother paper reports a mean incubation period of 5.2 days and the 95th percentile at 12.5 days 3.\nThere are reports of pre-symptomatic infections4, but these are reportedly rare 5 so in the following models we will assume: \\[T_{Incubation} = T_{Latent}\\] And so: \\[\\sigma = \\frac{1}{5.2} days^{-1}\\]\n\n\\(\\underline{T_{Infectious}}\\):\n\nAgain it is very difficult to say for sure and the period of communicability is very uncertain for COVID-19.\nResearch suggests a median of 20 days of viral shedding after onset of symptoms 6.\nRanging from 8 to 37 days in survivors.\nWhile it is noted PCR positivity does not necessarily reflect the infectious period (virus may not be viable but the PCR amplification will result in a positive), for the purpose of this blog post we will assume the following: \\[T_{Infectious} = T_{Clinical}\\] To obtain an exponential distribution with median M, the scale A is calculated as follows: \\[A = \\frac{M}{\\ln2} = \\frac{20}{\\ln2}\\] This results in \\[\\gamma = \\frac{\\ln2}{20} = \\frac{1}{28.85}\\ days^{-1}\\] * \\(\\underline{Beta= \\beta}\\):\nWhile difficult to estimate this parameter as there is a lot of variation between countries, cultures, societal norms, etc.. a little thought experiment can help us evaluate the value for \\(\\beta = r\\rho\\) in Switerland or France for example.\nIf no control measures are put in place and people do not change habits (as is the case in this blog post), we can expect the following:\n\nAverage number of contacts per day:\n\n\\[r = 10\\ contacts\\ per\\ day\\]\n\nAverage probability of transmission from contact:\n\n\\[\\rho = 5\\%\\]\nAnd so: \\[\\beta = r\\rho = 0.5\\]\n\n\nRunning the simulation\n\n\nCode\n#Define parameters\ndays = 200\nN = 10000\ninit = 1 - 1/N, 1/N, 0, 0\nsigma = 1/5.2\nbeta = 0.5\ngam = 1/28.85\nparms = sigma, beta, gam\n\n# Run simulation\nresults_avg = seir_model(init, parms, days)\n\n\n\n\nCode\nfig = go.Figure(data=[       \n    go.Scatter(name='S', x=np.linspace(0,days,days*10), y=results_avg.T[0], line={'dash':'solid', 'color':'blue'}),\n    go.Scatter(name='E', x=np.linspace(0,days,days*10), y=results_avg.T[1], line={'dash':'solid', 'color':'yellow'}),\n    go.Scatter(name='I', x=np.linspace(0,days,days*10), y=results_avg.T[2], line={'dash':'solid', 'color':'red'}), \n    go.Scatter(name='R', x=np.linspace(0,days,days*10), y=results_avg.T[3], line={'dash':'solid', 'color':'green'}),\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n  title={\n      'text':'Deterministic SEIR model - COVID-19 parameters',\n      'x':0.5,\n      'xanchor':'center'\n    }\n)\nfig.update_layout(height=500, template=\"plotly_dark\")\n\nfig.show()"
  },
  {
    "objectID": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#qualitative-analysis-of-beta-sigma-and-gamma",
    "href": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#qualitative-analysis-of-beta-sigma-and-gamma",
    "title": "Epidemic modeling - Part 2",
    "section": "Qualitative analysis of \\(\\beta\\), \\(\\sigma\\), and \\(\\gamma\\)",
    "text": "Qualitative analysis of \\(\\beta\\), \\(\\sigma\\), and \\(\\gamma\\)\n\nEffect of \\(\\sigma\\) (\\(T_{Latent}\\))\nLet’s have a look at the effect of \\(\\sigma\\) (or inversely, the latent period) on the SEIR simulation.\nA higher \\(\\sigma\\) means shorter average latent period, and vice-versa.\n\n\nCode\n## Let's try to see how the model changes \ndays = 1000\nN = 10000\ninit = 1 - 1/N, 1/N, 0, 0\nsigma_high = 1   # 1 --&gt; Average 1 day from E --&gt; I (ressembles SIR model)\nsigma_low = 1/100 #10 days on average, twice as long as COVID-19\nsigma_covid = 1/5.2\nbeta = 0.5\ngam = 1/28.85\nparms_fastEI = sigma_high, beta, gam\nparms_slowEI = sigma_low, beta, gam\nparms_avg = sigma_covid, beta, gam\n\n# Run simulation\nresults_fastEtoI = seir_model(init, parms_fastEI, days)\nresults_slowEtoI = seir_model(init, parms_slowEI, days)\nresults_avg = seir_model(init, parms_avg, days)\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name=r'$S:\\sigma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[0], line={'dash':'solid', 'color':'blue'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[1], line={'dash':'solid', 'color':'yellow'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[2], line={'dash':'solid', 'color':'red'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[3], line={'dash':'solid', 'color':'green'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{high}$', x=np.linspace(0,days,days*10), y=results_fastEtoI.T[0], line={'dash':'dash','color':'blue'}, legendgroup=\"high\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{high}$', x=np.linspace(0,days,days*10), y=results_fastEtoI.T[1], line={'dash':'dash', 'color':'yellow'}, legendgroup=\"high\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{high}$', x=np.linspace(0,days,days*10), y=results_fastEtoI.T[2], line={'dash':'dash', 'color':'red'}, legendgroup=\"high\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{high}$', x=np.linspace(0,days,days*10), y=results_fastEtoI.T[3], line={'dash':'dash', 'color':'green'}, legendgroup=\"high\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{low}$', x=np.linspace(0,days,days*10), y=results_slowEtoI.T[0], line={'dash':'dot', 'color':'blue'}, legendgroup=\"slow\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{low}$', x=np.linspace(0,days,days*10), y=results_slowEtoI.T[1], line={'dash':'dot', 'color':'yellow'}, legendgroup=\"slow\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{low}$', x=np.linspace(0,days,days*10), y=results_slowEtoI.T[2], line={'dash':'dot', 'color':'red'}, legendgroup=\"slow\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\sigma_{low}$', x=np.linspace(0,days,days*10), y=results_slowEtoI.T[3], line={'dash':'dot', 'color':'green'}, legendgroup=\"slow\", hoverinfo='x+y'),\n])\n\nfig.update_layout(\n    template='plotly_dark',\n    height=500,\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of } \\sigma \\ \\text{on Deterministic SEIR model}$',\n        #'text':'Effect of sigma on Deterministic SEIR model',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nWe notice a few things from the plot above on the impact of the average time from E → I:\n\nThe shorter the latent period:\n\nthe faster the epidemic propogates in the population\nthe higher the peak of infected individuals will be (meaning a higher chance hospital resources will be saturated)\n\nHowever, the latent period has no impact on the total number of individuals infected over the entire time of the epidemic.\n\n\n\nEffect of \\(\\beta = r~\\rho\\)\nLet’s have a look at the effect of \\(\\beta\\) on the SEIR simulation.\nA higher \\(\\beta\\) can either mean a higher average number of contacts per day (\\(r\\)) in the population and/or a higher probability of transmission of disease from I → S.\nThe opposite holds also.\n\n\nCode\n## Let's try to see how the model changes \ndays = 500\nN = 10000\ninit = 1 - 1/N, 1/N, 0, 0\nsigma_avg = 1/5.2\nbeta_avg = 0.5\nbeta_noepi = 1/30\nbeta_low = 0.1\nbeta_high = 4\ngam = 1/28.85\nparms_avg = sigma_avg, beta_avg, gam\nparms_noepi = sigma_avg, beta_noepi, gam \nparms_low = sigma_avg, beta_low, gam\nparms_high = sigma_avg, beta_high, gam\n\n# Run simulation\nresults_avg = seir_model(init, parms_avg, days)\nresults_noepi = seir_model(init, parms_noepi, days)\nresults_low = seir_model(init, parms_low, days)\nresults_high = seir_model(init, parms_high, days)\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name=r'$S:\\beta_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[0], line={'dash':'solid', 'color':'blue'}, legendgroup=\"COVID\"),\n    go.Scatter(name=r'$E:\\beta_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[1], line={'dash':'solid', 'color':'yellow'}, legendgroup=\"COVID\"), \n    go.Scatter(name=r'$I:\\beta_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[2], line={'dash':'solid', 'color':'red'}, legendgroup=\"COVID\"),\n    go.Scatter(name=r'$R:\\beta_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[3], line={'dash':'solid', 'color':'green'}, legendgroup=\"COVID\"),\n    go.Scatter(name=r'$S:\\beta_{noepi}$', x=np.linspace(0,days,days*10), y=results_noepi.T[0], line={'dash':'dashdot','color':'blue'}, legendgroup=\"noepi\"),\n    go.Scatter(name=r'$E:\\beta_{noepi}$', x=np.linspace(0,days,days*10), y=results_noepi.T[1], line={'dash':'dashdot', 'color':'yellow'}, legendgroup=\"noepi\"),\n    go.Scatter(name=r'$I:\\beta_{noepi}$', x=np.linspace(0,days,days*10), y=results_noepi.T[2], line={'dash':'dashdot', 'color':'red'}, legendgroup=\"noepi\"),\n    go.Scatter(name=r'$R:\\beta_{noepi}$', x=np.linspace(0,days,days*10), y=results_noepi.T[3], line={'dash':'dashdot', 'color':'green'}, legendgroup=\"noepi\"),\n    go.Scatter(name=r'$S:\\beta_{low}$', x=np.linspace(0,days,days*10), y=results_low.T[0], line={'dash':'dash','color':'blue'}, legendgroup=\"low\"),\n    go.Scatter(name=r'$E:\\beta_{low}$', x=np.linspace(0,days,days*10), y=results_low.T[1], line={'dash':'dash', 'color':'yellow'}, legendgroup=\"low\"),\n    go.Scatter(name=r'$I:\\beta_{low}$', x=np.linspace(0,days,days*10), y=results_low.T[2], line={'dash':'dash', 'color':'red'}, legendgroup=\"low\"),\n    go.Scatter(name=r'$R:\\beta_{low}$', x=np.linspace(0,days,days*10), y=results_low.T[3], line={'dash':'dash', 'color':'green'}, legendgroup=\"low\"),\n    go.Scatter(name=r'$S:\\beta_{high}$', x=np.linspace(0,days,days*10), y=results_high.T[0], line={'dash':'dot', 'color':'blue'}, legendgroup=\"high\"),\n    go.Scatter(name=r'$E:\\beta_{high}$', x=np.linspace(0,days,days*10), y=results_high.T[1], line={'dash':'dot', 'color':'yellow'}, legendgroup=\"high\"),\n    go.Scatter(name=r'$I:\\beta_{high}$', x=np.linspace(0,days,days*10), y=results_high.T[2], line={'dash':'dot', 'color':'red'}, legendgroup=\"high\"),\n    go.Scatter(name=r'$R:\\beta_{high}$', x=np.linspace(0,days,days*10), y=results_high.T[3], line={'dash':'dot', 'color':'green'}, legendgroup=\"high\"),\n])\n\nfig.update_layout(\n    #template='ggplot2',\n    height=500,\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of } \\beta \\ \\text{on Deterministic SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nWe notice a few things from the plot above on the impact of \\(\\beta\\):\n\nThe higher \\(\\beta\\) is:\n\nthe faster the epidemic seems to propogate in the population\nthe higher the peak of infected individuals seems to be (meaning a higher chance hospital resources will be saturated)\n\n\\(\\beta\\) also appears to affect the overall number of people infected over the course of the epidemic\nA low \\(\\beta\\) means a low \\(R_0\\) and we have seen in the first part of this blog that no epidemic occurs when \\(R_0 &lt; 1\\)\nBut even if \\(R_0 &gt; 1\\), keeping \\(\\beta\\) low reduces the total number of people infected\n\n\n\nEffect of \\(\\gamma\\) (\\(T_{Infectious}\\))\nLet’s have a look at the effect of \\(\\gamma\\) on the SEIR simulation.\nA higher \\(\\gamma\\) means a shorter infectious period, and vice-versa.\n\n\nCode\n## Let's try to see how the model changes \ndays = 500\nN = 10000\ninit = 1 - 1/N, 1/N, 0, 0\nsigma_avg = 1/5.2\nbeta = 0.5\ngam_avg = 1/28.85\ngam_low = 1/200\ngam_high = 0.2\nparms_fastIR = sigma_avg, beta, gam_high\nparms_slowIR = sigma_avg, beta, gam_low\nparms_avg = sigma_avg, beta, gam_avg\n\n# Run simulation\nresults_fastItoR = seir_model(init, parms_fastIR, days)\nresults_slowItoR = seir_model(init, parms_slowIR, days)\nresults_avg = seir_model(init, parms_avg, days)\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name=r'$S:\\gamma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[0], line={'dash':'solid', 'color':'blue'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[1], line={'dash':'solid', 'color':'yellow'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[2], line={'dash':'solid', 'color':'red'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{COVID}$', x=np.linspace(0,days,days*10), y=results_avg.T[3], line={'dash':'solid', 'color':'green'}, legendgroup=\"COVID\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{high}$', x=np.linspace(0,days,days*10), y=results_fastItoR.T[0], line={'dash':'dash','color':'blue'}, legendgroup=\"fast\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{high}$', x=np.linspace(0,days,days*10), y=results_fastItoR.T[1], line={'dash':'dash', 'color':'yellow'}, legendgroup=\"fast\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{high}$', x=np.linspace(0,days,days*10), y=results_fastItoR.T[2], line={'dash':'dash', 'color':'red'}, legendgroup=\"fast\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{high}$', x=np.linspace(0,days,days*10), y=results_fastItoR.T[3], line={'dash':'dash', 'color':'green'}, legendgroup=\"fast\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{low}$', x=np.linspace(0,days,days*10), y=results_slowItoR.T[0], line={'dash':'dot', 'color':'blue'}, legendgroup=\"slow\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{low}$', x=np.linspace(0,days,days*10), y=results_slowItoR.T[1], line={'dash':'dot', 'color':'yellow'}, legendgroup=\"slow\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{low}$', x=np.linspace(0,days,days*10), y=results_slowItoR.T[2], line={'dash':'dot', 'color':'red'}, legendgroup=\"slow\", hoverinfo='x+y'),\n    go.Scatter(name=r'$S:\\gamma_{low}$', x=np.linspace(0,days,days*10), y=results_slowItoR.T[3], line={'dash':'dot', 'color':'green'}, legendgroup=\"slow\", hoverinfo='x+y'),\n])\n\nfig.update_layout(\n    #template='ggplot2',\n    height=500,\n    xaxis_title = 'Day',\n    yaxis_title = 'Proportion of population',\n    title={\n        'text':r'$\\text{Effect of } \\gamma \\ \\text{on Deterministic SEIR model}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nWe notice a few things from the plot above on the impact of the infectious period:\n\nThe longer the infectious period:\n\nthe faster the epidemic propogates in the population\nthe higher the peak of infectious individuals will be and the longer it will last (meaning a higher chance hospital resources will be saturated)\n\nAs opposed to the latent period above, but similarly as \\(\\beta\\), the infectious period has an impact on the total number of individuals infected over the entire time of the epidemic\nWith no epidemic if \\(\\gamma &gt; \\beta\\)"
  },
  {
    "objectID": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#discussion",
    "href": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#discussion",
    "title": "Epidemic modeling - Part 2",
    "section": "Discussion",
    "text": "Discussion\nSo we can see the latent and infectious periods, along with the value of \\(\\beta\\) are critical components in how the model will react.\nWorth noting also is that the higher \\(R_0\\) is, the faster the epidemic spreads and the higher the peak of infectious individuals will be (see further blog posts for some nuance on this).\nNotably, and as predicted in part 1 of the blog series, no epidemic occurs if: \\[R_0 &lt; 1\\] In other words, no epidemic if: \\[\\beta &lt; \\gamma\\]\nThere are major flaws with this model however. While this model is deterministic and uses average time to model \\(\\sigma\\) and \\(\\gamma\\), this is a major flaw and does not represent the reality for most diseases.\nPart 3 of this blog series will discuss this further."
  },
  {
    "objectID": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#footnotes",
    "href": "posts/2020-03-18-deterministic-numerical-solutions/2020-03-18-deterministic-numerical-solutions.html#footnotes",
    "title": "Epidemic modeling - Part 2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWHO COVID-19 Situation Report 73↩︎\nCDC COVID-19 FAQ↩︎\nEarly Transmission Dynamics in Wuhan, China, of Novel Coronavirus–Infected Pneumonia↩︎\nCDC COVID-19 FAQ↩︎\nWHO COVID-19 Situation Report 73↩︎\nClinical course and mortality risk of server COVID-19↩︎"
  },
  {
    "objectID": "posts/2020-03-12-COVID-19-Tracker/2020-03-12-COVID-19-Tracker.html#link-to-tracker",
    "href": "posts/2020-03-12-COVID-19-Tracker/2020-03-12-COVID-19-Tracker.html#link-to-tracker",
    "title": "COVID-19 Tracker Map",
    "section": "Link to tracker",
    "text": "Link to tracker\nFollow this link."
  },
  {
    "objectID": "posts/2020-03-12-COVID-19-Tracker/2020-03-12-COVID-19-Tracker.html#about",
    "href": "posts/2020-03-12-COVID-19-Tracker/2020-03-12-COVID-19-Tracker.html#about",
    "title": "COVID-19 Tracker Map",
    "section": "About",
    "text": "About\nThere are already many great ways to visualize the spread of sars-cov-2 around the world. I’ve made another one for family and friends that has the world on one page and France on another.\nYou can click on the countries for more details on the world map.\nLikewise you can click on specific departments to see more detail on the French map.\nThe world map uses data aggregated by the John Hopkins University CSSE.\nThe french map uses hospitalization and intensive care data from Sante Publique France."
  },
  {
    "objectID": "posts/2020-03-12-COVID-19-Tracker/2020-03-12-COVID-19-Tracker.html#future-blog-post-about-building-the-site",
    "href": "posts/2020-03-12-COVID-19-Tracker/2020-03-12-COVID-19-Tracker.html#future-blog-post-about-building-the-site",
    "title": "COVID-19 Tracker Map",
    "section": "Future blog post about building the site",
    "text": "Future blog post about building the site\nThe site is built using Plotly Dash and deployed to Heroku.\nI will likely make a blog post detailing how to build the app and deploy it."
  },
  {
    "objectID": "posts/2020-06-02-real-world/2020-06-02-real-world.html",
    "href": "posts/2020-06-02-real-world/2020-06-02-real-world.html",
    "title": "Epidemic modeling - Part 8",
    "section": "",
    "text": "# This code wrangles the data from JHU\n\nimport pandas as pd\nimport numpy as np\n\nimport math\n\nfrom scipy import signal\n\nimport plotly.graph_objects as go\nimport plotly.express as px\n\nfrom scipy.stats import expon\nfrom scipy.stats import gamma\nfrom scipy.stats import weibull_min\n\nfrom numpy.random import default_rng\nrng = default_rng()\nimport plotly\nimport plotly.io as pio\nfrom IPython.display import display, HTML\n\n## Tomas Mazak's workaround\nplotly.offline.init_notebook_mode()\ndisplay(HTML(\n    #'&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_SVG\"&gt;&lt;/script&gt;'\n    '&lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.js\" charset=\"utf-8\"&gt;&lt;/script&gt;'\n))\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\npio.templates.default = \"plotly_dark\"\n\nimport datetime\n\n\n# Import confirmed cases\nconf_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv')\n\n#Import deaths data\ndeaths_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv')\n\n# Import recovery data\nrec_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv')\n\n#iso_alpha = pd.read_csv('https://raw.githubusercontent.com/jeffufpost/sars-cov-2-world-tracker/master/data/iso_alpha.csv', index_col=0, header=0).T.iloc[0]\niso_alpha = pd.read_csv('https://raw.githubusercontent.com/jeffufpost/sars-cov-2-world-tracker/refs/heads/master/project/app/data/iso_alpha.csv', index_col=0, header=0)\n\n# Wrangle the data\n\n#print(\"Wrangling data by country.......\")\n# Consolidate countries (ie. frenc dom tom are included in France, etc..)\nconf_df = conf_df.groupby(\"Country/Region\")\nconf_df = conf_df.sum().reset_index()\nconf_df = conf_df.set_index('Country/Region')\n\ndeaths_df = deaths_df.groupby(\"Country/Region\")\ndeaths_df = deaths_df.sum().reset_index()\ndeaths_df = deaths_df.set_index('Country/Region')\n\nrec_df = rec_df.groupby(\"Country/Region\")\nrec_df = rec_df.sum().reset_index()\nrec_df = rec_df.set_index('Country/Region')\n\n# Remove Lat and Long columns\nconf_df = conf_df.iloc[:,3:]\ndeaths_df = deaths_df.iloc[:,3:]\nrec_df = rec_df.iloc[:,3:]\n\n# Convert country names to correct format for search with pycountry\nconf_df = conf_df.rename(index={'Congo (Brazzaville)': 'Congo', 'Congo (Kinshasa)': 'Congo, the Democratic Republic of the', 'Burma': 'Myanmar', 'Korea, South': 'Korea, Republic of', 'Laos': \"Lao People's Democratic Republic\", 'Taiwan*': 'Taiwan', \"West Bank and Gaza\":\"Palestine, State of\"})\n# Convert country names to correct format for search with pycountry\ndeaths_df = deaths_df.rename(index={'Congo (Brazzaville)': 'Congo', 'Congo (Kinshasa)': 'Congo, the Democratic Republic of the', 'Burma': 'Myanmar', 'Korea, South': 'Korea, Republic of', 'Laos': \"Lao People's Democratic Republic\", 'Taiwan*': 'Taiwan', \"West Bank and Gaza\":\"Palestine, State of\"})\n# Convert country names to correct format for search with pycountry\nrec_df = rec_df.rename(index={'Congo (Brazzaville)': 'Congo', 'Congo (Kinshasa)': 'Congo, the Democratic Republic of the', 'Burma': 'Myanmar', 'Korea, South': 'Korea, Republic of', 'Laos': \"Lao People's Democratic Republic\", 'Taiwan*': 'Taiwan', \"West Bank and Gaza\":\"Palestine, State of\"})\n\n# Convert dates to datime format\nconf_df.columns = pd.to_datetime(conf_df.columns, format='mixed')\ndeaths_df.columns = pd.to_datetime(deaths_df.columns, format='mixed')\nrec_df.columns = pd.to_datetime(rec_df.columns, format='mixed')\n\n# Create a per day dataframe\n#print(\"Creating new per day dataframes......\")\n# Create per day dataframes for cases, deaths, and recoveries - by pd.DatafRame.diff\nconf_df_pd = conf_df.diff(axis=1)\ndeaths_df_pd = deaths_df.diff(axis=1)\nrec_df_pd = rec_df.diff(axis=1)\n\n#print(\"Create infected dataframe = conf - deaths - recoveries\")\ninf_df = conf_df - deaths_df - rec_df\n\nconf_df_pd.iloc[:,0] = 0\nrec_df_pd.iloc[:,0] = 0\ndeaths_df_pd.iloc[:,0] = 0\ninf_df.iloc[:,0] = 0\n\n#print(\"Adding dataframes of 1st, 2nd, and 3rd derivatives of number of infected\")\nfirstdev = inf_df.apply(np.gradient, axis=1)\nseconddev = firstdev.apply(np.gradient)\nthirddev = seconddev.apply(np.gradient)\n\n#print(\"Create series of first date above 100 confirmed cases.....\")\n# Create a column containing date at which 100 confirmed cases were reached, NaN if not reached yet\nfda100 = conf_df[conf_df &gt; 100].apply(pd.Series.first_valid_index, axis=1)\n\n# Create dataframe for probability plot\nprobevent = iso_alpha.join(inf_df)\nprobevent['prev'] = probevent.iloc[:,-1] / probevent['SP.POP.TOTL']\n# This code is the lowpass filter \ndef lowpass(x, fc=0.05, pad=0): # starts with cutoff freq at 0.05 but can be adjusted, should use 0.02 for France for example\n  \n  # Pad with last value\n  if pad == 1:\n    i=0\n    while i &lt; 100:\n      x=np.append(x, (x[-1]+x[-2]+x[-3])/3)\n      i=i+1\n\n  fs = 1  # Sampling frequency\n  t = np.arange(len(x.T)) #select number of days done in SEIR model\n  signala = x.T\n\n  #fc = 0.05  # Cut-off frequency of the filter\n  w = fc / (fs / 2) # Normalize the frequency\n  b, a = signal.butter(5, w, 'low')\n  return signal.filtfilt(b, a, signala), w\n# This code creates the impulse responses\ndays = np.arange(100)\ncdf = pd.DataFrame({\n    'T_Latent': gamma.cdf(days, 1.8,loc=0.9,scale=(5.2-1.8)/0.9), \n    'T_Infectious': weibull_min.cdf(days, 2.3,loc=2,scale=20.11)\n    })\nh_L = cdf.diff().T_Latent\nh_I = cdf.diff().T_Infectious\nh_L[0] = 0\nh_I[0] = 0\n# This code is for the iterative deconvolution\n# Let's define an iteration function:\ndef iter_deconv(alpha, impulse_response, input_signal, delay, comparator):\n  conv=signal.fftconvolve(impulse_response, input_signal, mode='full')\n  correction=np.roll(comparator-conv[:len(comparator)], delay)\n  input_signal=np.floor(lowpass(alpha*correction+input_signal, 0.05, 0)[0])\n  input_signal[input_signal&lt;0]=0\n  return input_signal\n\n# Define a function to return MSE between two signals as a measure of goodness of fit\ndef msecalc(A, B):\n  return ((A - B)**2).mean(axis=0)"
  },
  {
    "objectID": "posts/2020-06-02-real-world/2020-06-02-real-world.html#motivation-for-write-up",
    "href": "posts/2020-06-02-real-world/2020-06-02-real-world.html#motivation-for-write-up",
    "title": "Epidemic modeling - Part 8",
    "section": "Motivation for write-up",
    "text": "Motivation for write-up\nThis is the 8th part of a multi-part series blog post on modeling in epidemiology.\nWhile we have studied in detail the stochastc SEIR model, we have not compared this to actual real-world data.\nThe goal of this 8th installment is to expand on the 7th blog post and use deconvolution techniques on real world data to estimate the various parameters.\nMost notably, we want to calculate \\(R\\) from available data from JHU, let’s see how to go about this."
  },
  {
    "objectID": "posts/2020-06-02-real-world/2020-06-02-real-world.html#data-available",
    "href": "posts/2020-06-02-real-world/2020-06-02-real-world.html#data-available",
    "title": "Epidemic modeling - Part 8",
    "section": "Data available",
    "text": "Data available\nWe will use the JHU data which is updated daily and displayed graphically on my tracker here.\nA lot of countries have had difficulty reporting reliable data, but a few have done so rather well.\nWe will have a closer look at these contries:\n\nAustria\nFrance\nGermany\nSwitzerland\nUnited States\n\nThe JHU datasets include the following data:\n\nDaily cumulative confirmed cases\nDaily cumulative recoveries\nDaily cumulative deaths\n\nFrom which we can calculate the following:\n\nDaily new confirmed cases: \\(I_{pd}\\)\nDaily new recoveries\nDaily new deaths\nCurrent number of cases: \\(I\\)"
  },
  {
    "objectID": "posts/2020-06-02-real-world/2020-06-02-real-world.html#analysis",
    "href": "posts/2020-06-02-real-world/2020-06-02-real-world.html#analysis",
    "title": "Epidemic modeling - Part 8",
    "section": "Analysis",
    "text": "Analysis\n\nWe have seen previously how we can get \\(E_{pd}\\) from deconvolution of \\(I_{pd}\\).\nWe also know that:\n\n\\[E_{pd} = \\beta ~ I ~ \\frac{S}{N}\\] \\[\\leftrightarrow \\beta = \\frac{N ~ E_{pd}}{I ~ S}\\]\n\nAnd we know:\n\n\\[R_0 = \\frac{\\beta}{\\gamma}\\] and \\[R=R_0\\frac{S}{N}\\]\n\nSo:\n\n\\[E_{pd}=\\gamma~R~I\\] \\[\\leftrightarrow R = \\frac{E_{pd}}{\\gamma~I}\\]\nThis means we can find \\(R\\) by deconvolution of \\(I_{pd}\\).\nOur aim is to find this graphically in the real-world data."
  },
  {
    "objectID": "posts/2020-06-02-real-world/2020-06-02-real-world.html#real-world-analysis",
    "href": "posts/2020-06-02-real-world/2020-06-02-real-world.html#real-world-analysis",
    "title": "Epidemic modeling - Part 8",
    "section": "Real-world analysis",
    "text": "Real-world analysis\n\nGeneric analysis\nLet’s first have a look at the genral way we will go about the analysis (i.e. not country specific).\n\nWe have daily data \\(I_{pd}\\) and \\(R_{pd}\\)\nWe have our assumed \\(T_L\\) and \\(T_I\\)\n\nNote, depending on the data we have, \\(R_{pd}\\) can be:\n\nsum of deaths and recoveries\nonly deaths\nonly recoveries\n\nAnalysis steps:\n\nThe first thing we want to check is whether \\(h_I\\circledast I_{pd} [j]\\) gives us something close to \\(R_{pd}\\) If not, why not? (what kind of \\(R_{pd}\\) should we use?)\nCan we get an estimated \\(E_{pd}\\) by deconvolution of \\(I_{pd}\\) ? What cutoff frequency should we use ?\nWhat can that tell us about \\(R\\) and \\(\\beta\\) ?\n\n\n\nAustria\nLets first have a look at data from Austria\nUse fc = 0.05\n\n1. Checking \\(h_I\\)\n\n\nCode\nfig = go.Figure(data=[    \n    go.Bar(name='Ipd', x=conf_df_pd.loc['Austria'].index, y=conf_df_pd.loc['Austria']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=conf_df_pd.loc['Austria'].index, y=lowpass(conf_df_pd.loc['Austria'], 0.05, 1)[0]),\n    go.Bar(name='Rpd', x=rec_df_pd.loc['Austria'].index, y=rec_df_pd.loc['Austria']),\n    go.Scatter(name='Rpd=lowpass(Rpd)', x=rec_df_pd.loc['Austria'].index, y=lowpass(rec_df_pd.loc['Austria'], 0.05, 1)[0]),\n    go.Scatter(name='Rpd=conv(Ipd)', x=conf_df_pd.loc['Austria'].index, y=signal.fftconvolve(h_I, conf_df_pd.loc['Austria'], mode='full'))\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Austria: Actual } R_{pd} \\text{ vs. } h_I[j]\\circledast I_{pd}[j]$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nWe can see the actual \\(R_{pd}\\) leads \\(h_I[j]\\circledast I_{pd}[j]\\) by about 5 days.\nThere is a 20 day lag between peak \\(I_{pd}\\) and \\(h_I[j]\\circledast I_{pd}[j]\\) as is expected since \\(E[T_I] = 20.11\\).\nBut there is only a 15 day lag between peak \\(I_{pd}\\) and actual \\(R_{pd}\\).\nThere are a few possibilites for why this is the case, including that maybe we haven’t assumed the correct distribution for \\(T_I\\).\nHowever there is another reason why this could be. Testing, especially in the early days, took time, and it took time for a patient showing symptoms before he could be tested. This may simply explain the 5 day difference.\n\n\n2. Estimating \\(E_{pd}\\) by deconvolution of \\(I_{pd}\\)\n\n\nCode\n#Settting up for deconvolution of Ipd\n\n#regularization parameter\nalpha=2\n\n# Setup up the resultant Ipd we want to compare our guess with\nIpd=np.floor(lowpass(conf_df_pd.loc['Austria'], 0.05, 1)[0])\nIpd[Ipd&lt;0]=0\n\n\n# Pad with last value\ni=0\nwhile i &lt; 100:\n  Ipd=np.append(Ipd, Ipd[-1])\n  i=i+1\n\n# Find delay caused by h_L\ndelay=Ipd.argmax()-signal.fftconvolve(Ipd, h_L, mode='full').argmax()\n\n# We want initial guess to simply be the result of the convolution delayed\ninitial_guess=np.roll(Ipd,delay)\nEnext = initial_guess\n\n# AN array to record MSE between result we want and our iterated guess\nmse=np.array([])\nmse=np.append(mse, 10000000)\nmse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['Austria'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Austria'])]))\n\nitercount=0\nwhile mse[-1] &lt; mse[-2]:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  mse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['Austria'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Austria'])]))\n  print(\"Iteration #\" + str(itercount) +\": MSE= \"+str(mse[itercount]))\nprint(\"Iteration #\" + str(itercount+1) +\": MSE= \"+str(mse[-1])+\" so we use the result of the previous iteration.\")\n\n\nIteration #1: MSE= 280097.036893302\nIteration #2: MSE= 146227.1215060887\nIteration #3: MSE= 98427.81506218898\nIteration #4: MSE= 73637.12813586244\nIteration #5: MSE= 59569.91412113941\nIteration #6: MSE= 50477.19976409924\nIteration #7: MSE= 44172.759377519884\nIteration #8: MSE= 39507.84001002058\nIteration #9: MSE= 35832.886697091635\nIteration #10: MSE= 32875.44754973414\nIteration #11: MSE= 30378.109945193886\nIteration #12: MSE= 28271.241453430164\nIteration #13: MSE= 26418.481502302486\nIteration #14: MSE= 24812.840293680038\nIteration #15: MSE= 23369.96252175532\nIteration #16: MSE= 22096.63295282359\nIteration #17: MSE= 20937.04493230752\nIteration #18: MSE= 19894.25464484861\nIteration #19: MSE= 18948.959639641937\nIteration #20: MSE= 18087.458410139705\nIteration #21: MSE= 17300.24920923025\nIteration #22: MSE= 16577.668006392993\nIteration #23: MSE= 15919.451464138658\nIteration #24: MSE= 15300.907044372325\nIteration #25: MSE= 14744.675161225703\nIteration #26: MSE= 14210.683741229928\nIteration #27: MSE= 13738.119685289568\nIteration #28: MSE= 13277.832201974481\nIteration #29: MSE= 12873.332911900452\nIteration #30: MSE= 12469.245964828155\nIteration #31: MSE= 12118.224107328258\nIteration #32: MSE= 11759.266569961683\nIteration #33: MSE= 11449.777699700899\nIteration #34: MSE= 11131.659957279466\nIteration #35: MSE= 10862.139479901662\nIteration #36: MSE= 10573.068671552284\nIteration #37: MSE= 10333.756345607035\nIteration #38: MSE= 10076.654598951065\nIteration #39: MSE= 9869.633801315156\nIteration #40: MSE= 9633.22719271893\nIteration #41: MSE= 9446.34059525184\nIteration #42: MSE= 9234.269853278713\nIteration #43: MSE= 9069.962204752354\nIteration #44: MSE= 8873.17786679817\nIteration #45: MSE= 8722.147391985161\nIteration #46: MSE= 8542.091515068189\nIteration #47: MSE= 8408.644590365482\nIteration #48: MSE= 8242.506167912048\nIteration #49: MSE= 8124.5120742979625\nIteration #50: MSE= 7972.987989366172\nIteration #51: MSE= 7860.598971287295\nIteration #52: MSE= 7719.458842114416\nIteration #53: MSE= 7621.323727533386\nIteration #54: MSE= 7490.83303769503\nIteration #55: MSE= 7397.583821951359\nIteration #56: MSE= 7275.316302386207\nIteration #57: MSE= 7189.32491143722\nIteration #58: MSE= 7075.608628838437\nIteration #59: MSE= 6997.154682468184\nIteration #60: MSE= 6891.669715931714\nIteration #61: MSE= 6820.000022095949\nIteration #62: MSE= 6721.931341894739\nIteration #63: MSE= 6656.7407297932405\nIteration #64: MSE= 6565.26035425735\nIteration #65: MSE= 6504.275624274783\nIteration #66: MSE= 6415.65849730165\nIteration #67: MSE= 6356.806568959921\nIteration #68: MSE= 6271.206123333204\nIteration #69: MSE= 6219.307514472439\nIteration #70: MSE= 6142.708483765\nIteration #71: MSE= 6091.546359145574\nIteration #72: MSE= 6016.050209112622\nIteration #73: MSE= 5970.812362169446\nIteration #74: MSE= 5899.285625677148\nIteration #75: MSE= 5856.977454190732\nIteration #76: MSE= 5789.3161213834255\nIteration #77: MSE= 5747.087950803278\nIteration #78: MSE= 5679.500338125397\nIteration #79: MSE= 5644.187795502721\nIteration #80: MSE= 5580.280680635593\nIteration #81: MSE= 5545.408603337125\nIteration #82: MSE= 5484.431089279458\nIteration #83: MSE= 5453.903477449285\nIteration #84: MSE= 5392.874348290648\nIteration #85: MSE= 5364.440269167762\nIteration #86: MSE= 5303.190820142333\nIteration #87: MSE= 5276.1559599142865\nIteration #88: MSE= 5213.2843928561315\nIteration #89: MSE= 5191.00685069678\nIteration #90: MSE= 5129.745895988969\nIteration #91: MSE= 5106.63148781604\nIteration #92: MSE= 5042.710735774585\nIteration #93: MSE= 5024.520050637905\nIteration #94: MSE= 4959.777967931582\nIteration #95: MSE= 4943.725600949425\nIteration #96: MSE= 4875.271873179566\nIteration #97: MSE= 4862.827566294938\nIteration #98: MSE= 4792.683670844245\nIteration #99: MSE= 4781.061053161295\nIteration #100: MSE= 4708.305556553567\nIteration #101: MSE= 4698.486640356369\nIteration #102: MSE= 4625.1221124404055\nIteration #103: MSE= 4618.192025470725\nIteration #104: MSE= 4543.737145194148\nIteration #105: MSE= 4537.3247396068155\nIteration #106: MSE= 4457.709296744921\nIteration #107: MSE= 4452.973657491515\nIteration #108: MSE= 4374.22356769199\nIteration #109: MSE= 4371.7699337178765\nIteration #110: MSE= 4290.38013436198\nIteration #111: MSE= 4288.1246576608555\nIteration #112: MSE= 4207.8772648029535\nIteration #113: MSE= 4207.635756498308\nIteration #114: MSE= 4126.245976598282\nIteration #115: MSE= 4128.613977751894 so we use the result of the previous iteration.\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n\nCode\n# We can keep going the iteration until lowest MSE\n\n#change alpha if you like\n#alpha=2\n\ni=0\nwhile i &lt; 10:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  print(msecalc(Ipd[:len(conf_df_pd.loc['Austria'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Austria'])]))\n  i=i+1\n\n\n4045.719721082141\n4050.0822986420108\n3968.020949588893\n3971.9486870943533\n3892.0850995742844\n3899.536417475003\n3820.717378063294\n3828.929375478409\n3750.356287600738\n3762.533035688165\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['Austria'].index, y=Enext),\n    go.Scatter(name='Ipd=conv(deconv(Ipd))', x=inf_df.loc['Austria'].index, y=signal.fftconvolve(h_L, Enext, mode='full')),\n    go.Bar(name='Ipd', x=inf_df.loc['Austria'].index, y=conf_df_pd.loc['Austria']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=inf_df.loc['Austria'].index, y=lowpass(conf_df_pd.loc['Austria'], 0.05, 1)[0])\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Austria: Actual } I_{pd} \\text{ vs. convolution of deconvolution of } I_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nWe can see that our estimate for \\(\\hat{E}_{pd}\\) must be close to the reality of \\(E_{pd}\\) as \\(I_{pd}\\) is almost identical to \\(\\hat{E}_{pd} \\circledast h_L\\).\nOf course, this holds only as long as our estimate of \\(h_L\\) is close to reality.\n\n\n3. \\(\\beta\\) and \\(R\\) from \\(E_{pd}\\) and \\(I\\)\nAs described above:\n\\[R = \\frac{E_{pd}}{\\gamma~I}\\]\n\n\nCode\n# Calculate R\ngam = 1/15 # As we say gamma is 1/20.11\nR = Enext[:len(inf_df.loc['Austria'])]*(1/gam)/inf_df.loc['Austria']\n\nfig = go.Figure(data=[    \n    go.Scatter(name='R', x=inf_df.loc['Austria'].index, y=R),\n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['Austria'].index, y=Enext),\n    go.Scatter(name='Inf', x=inf_df.loc['Austria'].index, y=inf_df.loc['Austria']),\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'R',\n    title={\n        'text':r'$\\text{Austria: R }$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\n\n\n\nFrance\nBetter to use fc = 0.02 here\n\n1. Checking \\(h_I\\)\n\n\nCode\nfig = go.Figure(data=[    \n    go.Bar(name='Ipd', x=conf_df_pd.loc['France'].index, y=conf_df_pd.loc['France']),\n    go.Scatter(name='Ipd=lowpass2(Ipd)', x=conf_df_pd.loc['France'].index, y=lowpass(conf_df_pd.loc['France'], 0.02, 1)[0]),\n    go.Bar(name='Rpd', x=rec_df_pd.loc['France'].index, y=rec_df_pd.loc['France']),\n    go.Scatter(name='Rpd=lowpass(Rpd)', x=rec_df_pd.loc['France'].index, y=lowpass(rec_df_pd.loc['France'], 0.05, 1)[0]),\n    go.Scatter(name='Rpd=conv(Ipd)', x=conf_df_pd.loc['France'].index, y=signal.fftconvolve(h_I, conf_df_pd.loc['France'], mode='full'))\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{France: Actual } R_{pd} \\text{ vs. } h_I[j]\\circledast I_{pd}[j]$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nData is not very good, reason for using fc = 0.02 and it helps below:\n\n\n2. Estimating \\(E_{pd}\\) by deconvolution of \\(I_{pd}\\)\n\n\nCode\n#Settting up for deconvolution of Ipd\n\n#regularization parameter\nalpha=2\n\n# Setup up the resultant Ipd we want to compare our guess with\nIpd=np.floor(lowpass(conf_df_pd.loc['France'], 0.02, 1)[0])\nIpd[Ipd&lt;0]=0\n\n\n# Pad with last value\n#i=0\n#while i &lt; 100:\n#  Ipd=np.append(Ipd, Ipd[-1])\n#  i=i+1\n\n  # Pad with last value\ni=0\nwhile i &lt; 100:\n  Ipd=np.append(Ipd, (Ipd[-1]+Ipd[-2]+Ipd[-3])/3)\n  i=i+1\n\n# Find delay caused by h_L\ndelay=Ipd.argmax()-signal.fftconvolve(Ipd, h_L, mode='full').argmax()\n\n# We want initial guess to simply be the result of the convolution delayed\ninitial_guess=np.roll(Ipd,delay)\nEnext = initial_guess\n\n# AN array to record MSE between result we want and our iterated guess\nmse=np.array([])\nmse=np.append(mse, 10000000)\nmse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['France'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['France'])]))\n\nitercount=0\nwhile mse[-1] &lt; mse[-2]:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  mse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['France'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['France'])]))\n  print(\"Iteration #\" + str(itercount) +\": MSE= \"+str(mse[itercount]))\nprint(\"Iteration #\" + str(itercount+1) +\": MSE= \"+str(mse[-1])+\" so we use the result of the previous iteration.\")\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\nIteration #1: MSE= 5117960.805173197\nIteration #2: MSE= 3499161.0414016345\nIteration #3: MSE= 2468765.918751717\nIteration #4: MSE= 1786386.8815557766\nIteration #5: MSE= 1323470.1559443003\nIteration #6: MSE= 1001401.8255418137\nIteration #7: MSE= 772354.3244014457\nIteration #8: MSE= 607010.4444506937\nIteration #9: MSE= 484862.3581576968\nIteration #10: MSE= 394188.8154134461\nIteration #11: MSE= 325000.97457803506\nIteration #12: MSE= 272538.38354350056\nIteration #13: MSE= 231236.16894034666\nIteration #14: MSE= 199391.9603553421\nIteration #15: MSE= 173542.9406322499\nIteration #16: MSE= 153351.63805547243\nIteration #17: MSE= 136400.27538110517\nIteration #18: MSE= 123014.6376307402\nIteration #19: MSE= 111405.96650838591\nIteration #20: MSE= 102164.86985448647\nIteration #21: MSE= 93883.8951162736\nIteration #22: MSE= 87250.13892510024\nIteration #23: MSE= 81093.55956665453\nIteration #24: MSE= 76158.05529130949\nIteration #25: MSE= 71435.47195192643\nIteration #26: MSE= 67647.28730219323\nIteration #27: MSE= 63906.12267511958\nIteration #28: MSE= 60915.54720078659\nIteration #29: MSE= 57885.05294406694\nIteration #30: MSE= 55464.40767825074\nIteration #31: MSE= 52955.59887159959\nIteration #32: MSE= 50963.76269131391\nIteration #33: MSE= 48849.74613627011\nIteration #34: MSE= 47183.84792588964\nIteration #35: MSE= 45382.09526294367\nIteration #36: MSE= 43979.24164634863\nIteration #37: MSE= 42433.27883460782\nIteration #38: MSE= 41229.26384994886\nIteration #39: MSE= 39882.45044731062\nIteration #40: MSE= 38849.55664430575\nIteration #41: MSE= 37667.64431271743\nIteration #42: MSE= 36767.98060766154\nIteration #43: MSE= 35731.45868521261\nIteration #44: MSE= 34946.7550807061\nIteration #45: MSE= 34029.742900730496\nIteration #46: MSE= 33342.894475716756\nIteration #47: MSE= 32522.862385817636\nIteration #48: MSE= 31916.45201976579\nIteration #49: MSE= 31187.81327085697\nIteration #50: MSE= 30647.55167140667\nIteration #51: MSE= 29995.472893250575\nIteration #52: MSE= 29517.392032814387\nIteration #53: MSE= 28925.45668634593\nIteration #54: MSE= 28497.159636377663\nIteration #55: MSE= 27965.963581730128\nIteration #56: MSE= 27584.20587020581\nIteration #57: MSE= 27100.03407350276\nIteration #58: MSE= 26757.618630965688\nIteration #59: MSE= 26321.781601950872\nIteration #60: MSE= 26009.520783036874\nIteration #61: MSE= 25613.659472379128\nIteration #62: MSE= 25335.91232337881\nIteration #63: MSE= 24971.66701703756\nIteration #64: MSE= 24719.682474591726\nIteration #65: MSE= 24387.491275182463\nIteration #66: MSE= 24155.452973964537\nIteration #67: MSE= 23849.91316848782\nIteration #68: MSE= 23638.102536841725\nIteration #69: MSE= 23356.283402406825\nIteration #70: MSE= 23161.54110279197\nIteration #71: MSE= 22901.012327520115\nIteration #72: MSE= 22723.265209073295\nIteration #73: MSE= 22484.071668611046\nIteration #74: MSE= 22318.13541324509\nIteration #75: MSE= 22097.284420563035\nIteration #76: MSE= 21945.821745274046\nIteration #77: MSE= 21739.42407249935\nIteration #78: MSE= 21599.915034412476\nIteration #79: MSE= 21408.719014736234\nIteration #80: MSE= 21278.935432505943\nIteration #81: MSE= 21105.77383027484\nIteration #82: MSE= 20986.225901249083\nIteration #83: MSE= 20822.080589428246\nIteration #84: MSE= 20710.126618486927\nIteration #85: MSE= 20553.066562937816\nIteration #86: MSE= 20449.062399898816\nIteration #87: MSE= 20305.357670963087\nIteration #88: MSE= 20209.30971064579\nIteration #89: MSE= 20073.969643279695\nIteration #90: MSE= 19982.680108911507\nIteration #91: MSE= 19859.311006546966\nIteration #92: MSE= 19772.48969804378\nIteration #93: MSE= 19649.49714898565\nIteration #94: MSE= 19570.370507858686\nIteration #95: MSE= 19458.989766479433\nIteration #96: MSE= 19383.155540388165\nIteration #97: MSE= 19276.965354173233\nIteration #98: MSE= 19205.128971845577\nIteration #99: MSE= 19105.679980529276\nIteration #100: MSE= 19037.709165334334\nIteration #101: MSE= 18943.756611711768\nIteration #102: MSE= 18881.742290247254\nIteration #103: MSE= 18792.71228377153\nIteration #104: MSE= 18733.09712431994\nIteration #105: MSE= 18649.356922243474\nIteration #106: MSE= 18594.00893076957\nIteration #107: MSE= 18512.684919970667\nIteration #108: MSE= 18459.506144369676\nIteration #109: MSE= 18385.092400136822\nIteration #110: MSE= 18335.618303809842\nIteration #111: MSE= 18263.364853763876\nIteration #112: MSE= 18215.161051658226\nIteration #113: MSE= 18146.82167886694\nIteration #114: MSE= 18101.289189910443\nIteration #115: MSE= 18035.783683764203\nIteration #116: MSE= 17989.563157832228\nIteration #117: MSE= 17928.81812671534\nIteration #118: MSE= 17886.32849765552\nIteration #119: MSE= 17826.681771837786\nIteration #120: MSE= 17786.231816142128\nIteration #121: MSE= 17730.421890696078\nIteration #122: MSE= 17694.008622428857\nIteration #123: MSE= 17636.49634457983\nIteration #124: MSE= 17600.93097532715\nIteration #125: MSE= 17547.703385247645\nIteration #126: MSE= 17511.03327740333\nIteration #127: MSE= 17460.993258333427\nIteration #128: MSE= 17426.289098588026\nIteration #129: MSE= 17377.923688590105\nIteration #130: MSE= 17346.45974787351\nIteration #131: MSE= 17300.301501174756\nIteration #132: MSE= 17271.053601704396\nIteration #133: MSE= 17226.252685626314\nIteration #134: MSE= 17196.263116138143\nIteration #135: MSE= 17154.036524512954\nIteration #136: MSE= 17126.639467699053\nIteration #137: MSE= 17086.975999132606\nIteration #138: MSE= 17061.369020511705\nIteration #139: MSE= 17020.043412831164\nIteration #140: MSE= 16993.086016782392\nIteration #141: MSE= 16956.122216952095\nIteration #142: MSE= 16932.041833439707\nIteration #143: MSE= 16894.63026082054\nIteration #144: MSE= 16871.222439960944\nIteration #145: MSE= 16833.920715595737\nIteration #146: MSE= 16810.430259674067\nIteration #147: MSE= 16774.382336436876\nIteration #148: MSE= 16752.297663731042\nIteration #149: MSE= 16718.592035531652\nIteration #150: MSE= 16694.73120244851\nIteration #151: MSE= 16662.216563360376\nIteration #152: MSE= 16642.24930920911\nIteration #153: MSE= 16609.24851833289\nIteration #154: MSE= 16589.42491903914\nIteration #155: MSE= 16557.844463090674\nIteration #156: MSE= 16539.764780656278\nIteration #157: MSE= 16508.916637074104\nIteration #158: MSE= 16491.7120233013\nIteration #159: MSE= 16462.236392887324\nIteration #160: MSE= 16445.840009513857\nIteration #161: MSE= 16417.842786595476\nIteration #162: MSE= 16401.060581952508\nIteration #163: MSE= 16372.176192160174\nIteration #164: MSE= 16355.619323797577\nIteration #165: MSE= 16329.053873744771\nIteration #166: MSE= 16312.78745927229\nIteration #167: MSE= 16287.525501496004\nIteration #168: MSE= 16273.514281171914\nIteration #169: MSE= 16248.574012362944\nIteration #170: MSE= 16233.502381220185\nIteration #171: MSE= 16207.6173230868\nIteration #172: MSE= 16193.646902063929\nIteration #173: MSE= 16168.933010768356\nIteration #174: MSE= 16156.30063039807\nIteration #175: MSE= 16131.72764167814\nIteration #176: MSE= 16119.023096060057\nIteration #177: MSE= 16095.666422294615\nIteration #178: MSE= 16082.610177954266\nIteration #179: MSE= 16058.69008359635\nIteration #180: MSE= 16046.820857961895\nIteration #181: MSE= 16022.796541476928\nIteration #182: MSE= 16011.06818158278\nIteration #183: MSE= 15987.791123471306\nIteration #184: MSE= 15975.712302600152\nIteration #185: MSE= 15953.552933811581\nIteration #186: MSE= 15943.269293004003\nIteration #187: MSE= 15920.136222033112\nIteration #188: MSE= 15909.691648290083\nIteration #189: MSE= 15889.131431687952\nIteration #190: MSE= 15878.226783985763\nIteration #191: MSE= 15855.829456398604\nIteration #192: MSE= 15847.398353308003\nIteration #193: MSE= 15826.666109702275\nIteration #194: MSE= 15817.655034636287\nIteration #195: MSE= 15796.53948321836\nIteration #196: MSE= 15788.543369824518\nIteration #197: MSE= 15768.170596623606\nIteration #198: MSE= 15759.75542018989\nIteration #199: MSE= 15739.275448574028\nIteration #200: MSE= 15731.227727365633\nIteration #201: MSE= 15711.730093467388\nIteration #202: MSE= 15704.817237528549\nIteration #203: MSE= 15685.762132986054\nIteration #204: MSE= 15678.633662420483\nIteration #205: MSE= 15660.579766904706\nIteration #206: MSE= 15653.292821935827\nIteration #207: MSE= 15636.430033246625\nIteration #208: MSE= 15627.554356135823\nIteration #209: MSE= 15610.945604029603\nIteration #210: MSE= 15603.746862946895\nIteration #211: MSE= 15586.156432399022\nIteration #212: MSE= 15579.773727488786\nIteration #213: MSE= 15561.478054020394\nIteration #214: MSE= 15555.714926266843\nIteration #215: MSE= 15538.27924638053\nIteration #216: MSE= 15531.54785418079\nIteration #217: MSE= 15514.882884944716\nIteration #218: MSE= 15508.316905943075\nIteration #219: MSE= 15492.249877602435\nIteration #220: MSE= 15485.058416271666\nIteration #221: MSE= 15468.206964663017\nIteration #222: MSE= 15462.830324317474\nIteration #223: MSE= 15446.324515331247\nIteration #224: MSE= 15441.452382089226\nIteration #225: MSE= 15423.787783538908\nIteration #226: MSE= 15417.845641950138\nIteration #227: MSE= 15401.215287285762\nIteration #228: MSE= 15396.874555379341\nIteration #229: MSE= 15379.768939585469\nIteration #230: MSE= 15374.703793746698\nIteration #231: MSE= 15359.754242944002\nIteration #232: MSE= 15354.447392813581\nIteration #233: MSE= 15338.743428470243\nIteration #234: MSE= 15333.713841523362\nIteration #235: MSE= 15317.894920520106\nIteration #236: MSE= 15312.24483244489\nIteration #237: MSE= 15296.98486764927\nIteration #238: MSE= 15292.349722769733\nIteration #239: MSE= 15277.906982419268\nIteration #240: MSE= 15273.720286443047\nIteration #241: MSE= 15258.711851375814\nIteration #242: MSE= 15252.20364513739\nIteration #243: MSE= 15238.402464047384\nIteration #244: MSE= 15233.25748777765\nIteration #245: MSE= 15219.778835759176\nIteration #246: MSE= 15216.151753967033\nIteration #247: MSE= 15202.019079582995\nIteration #248: MSE= 15197.347316535446\nIteration #249: MSE= 15184.84686249038\nIteration #250: MSE= 15180.47417161207\nIteration #251: MSE= 15167.559836384089\nIteration #252: MSE= 15162.56194815394\nIteration #253: MSE= 15148.816471879534\nIteration #254: MSE= 15144.256996856007\nIteration #255: MSE= 15131.150515850835\nIteration #256: MSE= 15126.616699819802\nIteration #257: MSE= 15113.681035811553\nIteration #258: MSE= 15108.980866302414\nIteration #259: MSE= 15096.749746363821\nIteration #260: MSE= 15092.951356259222\nIteration #261: MSE= 15081.483567077576\nIteration #262: MSE= 15077.14782112155\nIteration #263: MSE= 15064.31830976379\nIteration #264: MSE= 15059.95924016886\nIteration #265: MSE= 15048.758065753747\nIteration #266: MSE= 15045.17066159609\nIteration #267: MSE= 15032.866484121587\nIteration #268: MSE= 15030.628370265009\nIteration #269: MSE= 15018.632308669052\nIteration #270: MSE= 15015.045680301353\nIteration #271: MSE= 15004.19357507284\nIteration #272: MSE= 15000.58468076094\nIteration #273: MSE= 14987.897025856882\nIteration #274: MSE= 14985.463060832295\nIteration #275: MSE= 14974.554599073244\nIteration #276: MSE= 14971.474782842488\nIteration #277: MSE= 14960.29354617457\nIteration #278: MSE= 14957.14625752821\nIteration #279: MSE= 14946.118517691404\nIteration #280: MSE= 14944.113964712637\nIteration #281: MSE= 14933.06954366123\nIteration #282: MSE= 14929.630066180982\nIteration #283: MSE= 14919.555775191899\nIteration #284: MSE= 14916.466318904275\nIteration #285: MSE= 14906.397882291029\nIteration #286: MSE= 14903.295906239666\nIteration #287: MSE= 14892.426019899116\nIteration #288: MSE= 14889.512614366968\nIteration #289: MSE= 14879.093223332717\nIteration #290: MSE= 14876.31146505587\nIteration #291: MSE= 14865.128027043767\nIteration #292: MSE= 14862.664259890578\nIteration #293: MSE= 14851.921722920672\nIteration #294: MSE= 14848.371201513535\nIteration #295: MSE= 14837.657635308185\nIteration #296: MSE= 14834.687399575452\nIteration #297: MSE= 14824.461543900603\nIteration #298: MSE= 14822.245578960115\nIteration #299: MSE= 14813.143058230637\nIteration #300: MSE= 14810.731450540767\nIteration #301: MSE= 14800.878607439694\nIteration #302: MSE= 14798.081284654872\nIteration #303: MSE= 14789.181334456998\nIteration #304: MSE= 14786.955954275983\nIteration #305: MSE= 14777.487212299087\nIteration #306: MSE= 14774.968910753127\nIteration #307: MSE= 14766.439804434205\nIteration #308: MSE= 14764.816207856351\nIteration #309: MSE= 14755.613942920982\nIteration #310: MSE= 14753.443151308926\nIteration #311: MSE= 14743.453067650824\nIteration #312: MSE= 14741.725410652674\nIteration #313: MSE= 14732.779952376051\nIteration #314: MSE= 14731.080001107563\nIteration #315: MSE= 14722.398336351967\nIteration #316: MSE= 14721.025982619012\nIteration #317: MSE= 14711.434933777673\nIteration #318: MSE= 14709.914048794442\nIteration #319: MSE= 14701.252249370285\nIteration #320: MSE= 14698.96975656556\nIteration #321: MSE= 14690.94520984386\nIteration #322: MSE= 14689.068340390802\nIteration #323: MSE= 14680.436206181841\nIteration #324: MSE= 14678.480401190543\nIteration #325: MSE= 14670.410456267866\nIteration #326: MSE= 14668.717030462152\nIteration #327: MSE= 14660.75437298348\nIteration #328: MSE= 14658.663327661468\nIteration #329: MSE= 14650.071236345375\nIteration #330: MSE= 14648.503131611511\nIteration #331: MSE= 14640.465960606854\nIteration #332: MSE= 14638.009267871212\nIteration #333: MSE= 14628.857324973023\nIteration #334: MSE= 14626.67834122902\nIteration #335: MSE= 14618.747572055225\nIteration #336: MSE= 14616.973223997942\nIteration #337: MSE= 14609.171701733261\nIteration #338: MSE= 14607.713229412178\nIteration #339: MSE= 14599.842022670447\nIteration #340: MSE= 14598.417399030297\nIteration #341: MSE= 14589.940722835196\nIteration #342: MSE= 14588.354728190427\nIteration #343: MSE= 14580.244802421248\nIteration #344: MSE= 14578.968077489324\nIteration #345: MSE= 14571.210383359443\nIteration #346: MSE= 14569.686697904353\nIteration #347: MSE= 14562.869630398956\nIteration #348: MSE= 14562.34226875458\nIteration #349: MSE= 14554.180949889407\nIteration #350: MSE= 14552.60367236601\nIteration #351: MSE= 14546.96461277427\nIteration #352: MSE= 14545.52188559763\nIteration #353: MSE= 14538.46839725189\nIteration #354: MSE= 14536.901757868212\nIteration #355: MSE= 14530.263029059091\nIteration #356: MSE= 14528.484853224292\nIteration #357: MSE= 14522.455942429573\nIteration #358: MSE= 14521.884549909768\nIteration #359: MSE= 14515.535776517396\nIteration #360: MSE= 14515.110074549486\nIteration #361: MSE= 14508.979616087048\nIteration #362: MSE= 14508.151475197024\nIteration #363: MSE= 14502.530112241322\nIteration #364: MSE= 14500.367201557287\nIteration #365: MSE= 14493.339521368667\nIteration #366: MSE= 14492.531973022938\nIteration #367: MSE= 14486.29288766241\nIteration #368: MSE= 14485.472778962987\nIteration #369: MSE= 14479.261746033815\nIteration #370: MSE= 14478.479622482693\nIteration #371: MSE= 14472.502908713977\nIteration #372: MSE= 14470.998444531786\nIteration #373: MSE= 14465.047490298395\nIteration #374: MSE= 14465.387767863645 so we use the result of the previous iteration.\n\n\n\n#collapse_hide\n# We can keep going the iteration until lowest MSE\n\n#change alpha if you like\nalpha=2\n\ni=0\nwhile i &lt; 10:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  print(msecalc(Ipd[:len(conf_df_pd.loc['France'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['France'])]))\n  i=i+1\n\n14459.852568613716\n14459.351561067231\n14453.957064700979\n14453.452195254797\n14447.490444532958\n14446.265432120781\n14439.930296478404\n14439.300086843774\n14433.80505894358\n14433.59714741496\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['France'].index, y=Enext),\n    go.Scatter(name='Ipd=conv(deconv(Ipd))', x=inf_df.loc['France'].index, y=signal.fftconvolve(h_L, Enext, mode='full')),\n    go.Bar(name='Ipd', x=inf_df.loc['France'].index, y=conf_df_pd.loc['France']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=inf_df.loc['France'].index, y=lowpass(conf_df_pd.loc['France'], 0.02, 1)[0])\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{France: Actual } I_{pd} \\text{ vs. convolution of deconvolution of } I_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\n\n\n3. \\(\\beta\\) and \\(R\\) from \\(E_{pd}\\) and \\(I\\)\nAs described above:\n\\[R = \\frac{E_{pd}}{\\gamma~I}\\]\n\n\nCode\n# Calculate R\ngam = 1/20.11 # As we say gamma is 1/20.11\nR = Enext[:len(inf_df.loc['France'])]*(1/gam)/inf_df.loc['France']\n\nfig = go.Figure(data=[    \n    go.Scatter(name='R', x=inf_df.loc['France'].index, y=R),\n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['France'].index, y=Enext),\n    go.Scatter(name='Inf', x=inf_df.loc['France'].index, y=inf_df.loc['France']),\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'R',\n    title={\n        'text':r'$\\text{France: R }$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nAfter March 15th we see a rapi decline in \\(R\\) until \\(R&lt;1\\) since April 12th, however the last 2 weeks of May have seen an increase and it is now close to 1 in early June.\n\n\n\nGermany\nUse fc = 0.05\n\n1. Checking \\(h_I\\)\n\n\nCode\nfig = go.Figure(data=[    \n    go.Bar(name='Ipd', x=conf_df_pd.loc['Germany'].index, y=conf_df_pd.loc['Germany']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=conf_df_pd.loc['Germany'].index, y=lowpass(conf_df_pd.loc['Germany'], 0.05, 1)[0]),\n    go.Bar(name='Rpd', x=rec_df_pd.loc['Germany'].index, y=rec_df_pd.loc['Germany']),\n    go.Scatter(name='Rpd=lowpass(Rpd)', x=rec_df_pd.loc['Germany'].index, y=lowpass(rec_df_pd.loc['Germany'], 0.05, 1)[0]),\n    go.Scatter(name='Rpd=conv(Ipd)', x=conf_df_pd.loc['Germany'].index, y=signal.fftconvolve(h_I, conf_df_pd.loc['Germany'], mode='full'))\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Germany: Actual } R_{pd} \\text{ vs. } h_I[j]\\circledast I_{pd}[j]$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nWe can see the actual \\(R_{pd}\\) lags \\(h_I[j]\\circledast I_{pd}[j]\\) by about 10 days.\nAlthough they are pretty close still.\n\n\n2. Estimating \\(E_{pd}\\) by deconvolution of \\(I_{pd}\\)\n\n\nCode\n#Settting up for deconvolution of Ipd\n\n#regularization parameter\nalpha=2\n\n# Setup up the resultant Ipd we want to compare our guess with\nIpd=np.floor(lowpass(conf_df_pd.loc['Germany'], 0.05, 1)[0])\nIpd[Ipd&lt;0]=0\n\n\n# Pad with last value\ni=0\nwhile i &lt; 100:\n  Ipd=np.append(Ipd, Ipd[-1])\n  i=i+1\n\n# Find delay caused by h_L\ndelay=Ipd.argmax()-signal.fftconvolve(Ipd, h_L, mode='full').argmax()\n\n# We want initial guess to simply be the result of the convolution delayed\ninitial_guess=np.roll(Ipd,delay)\nEnext = initial_guess\n\n# AN array to record MSE between result we want and our iterated guess\nmse=np.array([])\nmse=np.append(mse, 10000000)\nmse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['Germany'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Germany'])]))\n\nitercount=0\nwhile mse[-1] &lt; mse[-2]:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  mse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['Germany'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Germany'])]))\n  print(\"Iteration #\" + str(itercount) +\": MSE= \"+str(mse[itercount]))\nprint(\"Iteration #\" + str(itercount+1) +\": MSE= \"+str(mse[-1])+\" so we use the result of the previous iteration.\")\n\n\nIteration #1: MSE= 4480813.327614089\nIteration #2: MSE= 1779548.6584457145\nIteration #3: MSE= 1047028.0176745327\nIteration #4: MSE= 763775.8058749898\nIteration #5: MSE= 616594.4567051543\nIteration #6: MSE= 529747.000092582\nIteration #7: MSE= 476190.4914439757\nIteration #8: MSE= 439455.98413487274\nIteration #9: MSE= 413238.4188322324\nIteration #10: MSE= 393123.1685706109\nIteration #11: MSE= 377495.96667679405\nIteration #12: MSE= 364719.9359760672\nIteration #13: MSE= 354393.91268630454\nIteration #14: MSE= 345599.6601037873\nIteration #15: MSE= 338346.69244214304\nIteration #16: MSE= 331946.96865472384\nIteration #17: MSE= 326628.71291526343\nIteration #18: MSE= 321807.5307918656\nIteration #19: MSE= 317817.5391580721\nIteration #20: MSE= 314080.2491777902\nIteration #21: MSE= 311017.61641710735\nIteration #22: MSE= 308056.9970819047\nIteration #23: MSE= 305677.4624175552\nIteration #24: MSE= 303277.81373376475\nIteration #25: MSE= 301399.156928807\nIteration #26: MSE= 299424.407404202\nIteration #27: MSE= 297923.86043155007\nIteration #28: MSE= 296276.72521180415\nIteration #29: MSE= 295073.7223713621\nIteration #30: MSE= 293668.5313263045\nIteration #31: MSE= 292701.9214976401\nIteration #32: MSE= 291486.3663743539\nIteration #33: MSE= 290701.1734301538\nIteration #34: MSE= 289654.7917024821\nIteration #35: MSE= 288995.9194548779\nIteration #36: MSE= 288056.58729253773\nIteration #37: MSE= 287539.23734438093\nIteration #38: MSE= 286709.20267507294\nIteration #39: MSE= 286278.69113009755\nIteration #40: MSE= 285518.0192174311\nIteration #41: MSE= 285165.7646299935\nIteration #42: MSE= 284483.7725251523\nIteration #43: MSE= 284191.1919826371\nIteration #44: MSE= 283555.7338814083\nIteration #45: MSE= 283332.78778147144\nIteration #46: MSE= 282755.7882248326\nIteration #47: MSE= 282569.3144878955\nIteration #48: MSE= 282028.92531054956\nIteration #49: MSE= 281873.5443270758\nIteration #50: MSE= 281368.16484932543\nIteration #51: MSE= 281260.0466810068\nIteration #52: MSE= 280777.22983139596\nIteration #53: MSE= 280702.1100166799\nIteration #54: MSE= 280245.97881903534\nIteration #55: MSE= 280179.61994918366\nIteration #56: MSE= 279744.2434719691\nIteration #57: MSE= 279711.2099280925\nIteration #58: MSE= 279298.9192786068\nIteration #59: MSE= 279292.322029075\nIteration #60: MSE= 278889.48600294883\nIteration #61: MSE= 278901.1450810871 so we use the result of the previous iteration.\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n\nCode\n# We can keep going the iteration until lowest MSE\n\n#change alpha if you like\nalpha=2\n\ni=0\nwhile i &lt; 10:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  print(msecalc(Ipd[:len(conf_df_pd.loc['Germany'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Germany'])]))\n  i=i+1\n\n\n278505.5331361171\n278534.93735467247\n278160.17827383784\n278200.11201937246\n277842.2676195372\n277879.94690998486\n277532.45464883576\n277593.0411346929\n277256.49456925044\n277320.03160332504\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['Germany'].index, y=Enext),\n    go.Scatter(name='Ipd=conv(deconv(Ipd))', x=inf_df.loc['Germany'].index, y=signal.fftconvolve(h_L, Enext, mode='full')),\n    go.Bar(name='Ipd', x=inf_df.loc['Germany'].index, y=conf_df_pd.loc['Germany']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=inf_df.loc['Germany'].index, y=lowpass(conf_df_pd.loc['Germany'], 0.05, 1)[0])\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Germany: Actual } I_{pd} \\text{ vs. convolution of deconvolution of } I_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nWe can see that our estimate for \\(\\hat{E}_{pd}\\) must be close to the reality of \\(E_{pd}\\) as \\(I_{pd}\\) is almost identical to \\(\\hat{E}_{pd} \\circledast h_L\\).\nOf course, this holds only as long as our estimate of \\(h_L\\) is close to reality.\n\n\n3. \\(\\beta\\) and \\(R\\) from \\(E_{pd}\\) and \\(I\\)\nAs described above:\n\\[R = \\frac{E_{pd}}{\\gamma~I}\\]\n\n\nCode\n# Calculate R\ngam = 1/20.11 # As we say gamma is 1/20.11\nR = Enext[:len(inf_df.loc['Germany'])]*(1/gam)/inf_df.loc['Germany']\n\nfig = go.Figure(data=[    \n    go.Scatter(name='R', x=inf_df.loc['Germany'].index, y=R),\n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['Germany'].index, y=Enext),\n    go.Scatter(name='Inf', x=inf_df.loc['Germany'].index, y=inf_df.loc['Germany']),\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'R',\n    title={\n        'text':r'$\\text{Germany: R }$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nWe can see \\(R&lt;1\\) since April 3rd, however the peak \\(E_{pd}\\) is slightly ahead of that March 23rd.\n\n\n\nSwitzerland\n\n1. Checking \\(h_I\\)\n\n\nCode\nfig = go.Figure(data=[    \n    go.Bar(name='Ipd', x=conf_df_pd.loc['Switzerland'].index, y=conf_df_pd.loc['Switzerland']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=conf_df_pd.loc['Switzerland'].index, y=lowpass(conf_df_pd.loc['Switzerland'], 0.05, 1)[0]),\n    go.Bar(name='Rpd', x=rec_df_pd.loc['Switzerland'].index, y=rec_df_pd.loc['Switzerland']),\n    go.Scatter(name='Rpd=lowpass(Rpd)', x=rec_df_pd.loc['Switzerland'].index, y=lowpass(rec_df_pd.loc['Switzerland'], 0.05, 1)[0]),\n    go.Scatter(name='Rpd=conv(Ipd)', x=conf_df_pd.loc['Switzerland'].index, y=signal.fftconvolve(h_I, conf_df_pd.loc['Switzerland'], mode='full'))\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Switzerland: Actual } R_{pd} \\text{ vs. } h_I[j]\\circledast I_{pd}[j]$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nWe can see the actual \\(R_{pd}\\) leads \\(h_I[j]\\circledast I_{pd}[j]\\) by about 7 days.\n\n\n2. Estimating \\(E_{pd}\\) by deconvolution of \\(I_{pd}\\)\n\n\nCode\n#Settting up for deconvolution of Ipd\n\n#regularization parameter\nalpha=2\n\n# Setup up the resultant Ipd we want to compare our guess with\nIpd=np.floor(lowpass(conf_df_pd.loc['Switzerland'], 0.05, 1)[0])\nIpd[Ipd&lt;0]=0\n\n\n# Pad with last value\ni=0\nwhile i &lt; 100:\n  Ipd=np.append(Ipd, Ipd[-1])\n  i=i+1\n\n# Find delay caused by h_L\ndelay=Ipd.argmax()-signal.fftconvolve(Ipd, h_L, mode='full').argmax()\n\n# We want initial guess to simply be the result of the convolution delayed\ninitial_guess=np.roll(Ipd,delay)\nEnext = initial_guess\n\n# AN array to record MSE between result we want and our iterated guess\nmse=np.array([])\nmse=np.append(mse, 10000000)\nmse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['Switzerland'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Switzerland'])]))\n\nitercount=0\nwhile mse[-1] &lt; mse[-2]:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  mse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['Russia'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Switzerland'])]))\n  print(\"Iteration #\" + str(itercount) +\": MSE= \"+str(mse[itercount]))\nprint(\"Iteration #\" + str(itercount+1) +\": MSE= \"+str(mse[-1])+\" so we use the result of the previous iteration.\")\n\n\nIteration #1: MSE= 195938.77912974023\nIteration #2: MSE= 92598.5502258455\nIteration #3: MSE= 59128.50699903844\nIteration #4: MSE= 42822.838779538215\nIteration #5: MSE= 34413.74497872791\nIteration #6: MSE= 29397.444434795136\nIteration #7: MSE= 26266.214258011416\nIteration #8: MSE= 24082.409100474433\nIteration #9: MSE= 22492.896300229964\nIteration #10: MSE= 21225.357922625102\nIteration #11: MSE= 20202.622330079314\nIteration #12: MSE= 19310.44685085919\nIteration #13: MSE= 18545.582296652286\nIteration #14: MSE= 17842.045548122835\nIteration #15: MSE= 17220.157891847626\nIteration #16: MSE= 16635.43422388673\nIteration #17: MSE= 16109.62920614112\nIteration #18: MSE= 15607.948586339993\nIteration #19: MSE= 15157.358178709917\nIteration #20: MSE= 14719.405929680112\nIteration #21: MSE= 14321.39639162879\nIteration #22: MSE= 13937.747258224457\nIteration #23: MSE= 13580.699248153194\nIteration #24: MSE= 13238.287487807323\nIteration #25: MSE= 12923.05672740925\nIteration #26: MSE= 12615.873340651639\nIteration #27: MSE= 12333.948423913023\nIteration #28: MSE= 12060.586862965463\nIteration #29: MSE= 11806.337909513775\nIteration #30: MSE= 11556.829332708503\nIteration #31: MSE= 11324.758908874524\nIteration #32: MSE= 11097.827572308348\nIteration #33: MSE= 10889.767639511578\nIteration #34: MSE= 10684.970618385503\nIteration #35: MSE= 10495.827476306413\nIteration #36: MSE= 10309.372490124444\nIteration #37: MSE= 10136.62614083432\nIteration #38: MSE= 9962.25527682353\nIteration #39: MSE= 9806.712548334388\nIteration #40: MSE= 9645.55837753218\nIteration #41: MSE= 9504.786823092121\nIteration #42: MSE= 9360.478542703051\nIteration #43: MSE= 9227.271539507645\nIteration #44: MSE= 9091.223107875738\nIteration #45: MSE= 8969.29115341354\nIteration #46: MSE= 8844.02110950773\nIteration #47: MSE= 8731.449306161778\nIteration #48: MSE= 8614.192146629004\nIteration #49: MSE= 8512.411724441054\nIteration #50: MSE= 8402.36013411898\nIteration #51: MSE= 8306.971958009977\nIteration #52: MSE= 8206.804664945614\nIteration #53: MSE= 8116.658953537234\nIteration #54: MSE= 8021.574930314654\nIteration #55: MSE= 7938.3376066661285\nIteration #56: MSE= 7847.576233211533\nIteration #57: MSE= 7770.313752856979\nIteration #58: MSE= 7684.890990888229\nIteration #59: MSE= 7614.203469219121\nIteration #60: MSE= 7531.785696940037\nIteration #61: MSE= 7465.689114837634\nIteration #62: MSE= 7387.706935147723\nIteration #63: MSE= 7327.12672350847\nIteration #64: MSE= 7253.531286391747\nIteration #65: MSE= 7197.811648480507\nIteration #66: MSE= 7128.7513445972445\nIteration #67: MSE= 7077.0580090597905\nIteration #68: MSE= 7008.087621851146\nIteration #69: MSE= 6959.073688894325\nIteration #70: MSE= 6893.160330404095\nIteration #71: MSE= 6848.244073372437\nIteration #72: MSE= 6783.542205063829\nIteration #73: MSE= 6741.731420071753\nIteration #74: MSE= 6675.396365489819\nIteration #75: MSE= 6636.0554391552005\nIteration #76: MSE= 6572.390374418994\nIteration #77: MSE= 6536.405026680437\nIteration #78: MSE= 6470.231534183589\nIteration #79: MSE= 6437.400466541315\nIteration #80: MSE= 6369.952847739624\nIteration #81: MSE= 6337.158752046109\nIteration #82: MSE= 6267.110753591126\nIteration #83: MSE= 6234.511459392571\nIteration #84: MSE= 6164.3484413572905\nIteration #85: MSE= 6135.093346091662\nIteration #86: MSE= 6064.28180181078\nIteration #87: MSE= 6035.566267853741\nIteration #88: MSE= 5962.446284991836\nIteration #89: MSE= 5934.705069962215\nIteration #90: MSE= 5860.071406975256\nIteration #91: MSE= 5833.161439680613\nIteration #92: MSE= 5757.577703215929\nIteration #93: MSE= 5734.022807025684\nIteration #94: MSE= 5656.5955806182155\nIteration #95: MSE= 5632.317638378359\nIteration #96: MSE= 5555.332007992863\nIteration #97: MSE= 5533.556372087182\nIteration #98: MSE= 5458.3969114889\nIteration #99: MSE= 5436.268504588962\nIteration #100: MSE= 5359.929024443102\nIteration #101: MSE= 5341.18226004137\nIteration #102: MSE= 5266.790948124076\nIteration #103: MSE= 5250.868203079338\nIteration #104: MSE= 5177.763832631689\nIteration #105: MSE= 5162.957706817038\nIteration #106: MSE= 5092.904915671228\nIteration #107: MSE= 5080.8933161121495\nIteration #108: MSE= 5014.749809938904\nIteration #109: MSE= 5005.743957352035\nIteration #110: MSE= 4943.5104626660495\nIteration #111: MSE= 4937.749021715691\nIteration #112: MSE= 4878.624288317557\nIteration #113: MSE= 4875.938516831257\nIteration #114: MSE= 4820.54753118064\nIteration #115: MSE= 4818.20354907714\nIteration #116: MSE= 4767.369486952111\nIteration #117: MSE= 4769.003831843811 so we use the result of the previous iteration.\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n\nCode\n# We can keep going the iteration until lowest MSE\n\n#change alpha if you like\nalpha=2\n\ni=0\nwhile i &lt; 10:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  print(msecalc(Ipd[:len(conf_df_pd.loc['Switzerland'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['Switzerland'])]))\n  i=i+1\n\n\n4723.25082742416\n4725.699669287725\n4683.134053574572\n4687.788070251505\n4650.55132533759\n4656.470026778366\n4620.760015152314\n4626.699797431839\n4596.550489682245\n4604.349708285622\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['Switzerland'].index, y=Enext),\n    go.Scatter(name='Ipd=conv(deconv(Ipd))', x=inf_df.loc['Switzerland'].index, y=signal.fftconvolve(h_L, Enext, mode='full')),\n    go.Bar(name='Ipd', x=inf_df.loc['Switzerland'].index, y=conf_df_pd.loc['Switzerland']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=inf_df.loc['Switzerland'].index, y=lowpass(conf_df_pd.loc['Switzerland'], 0.05, 1)[0])\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{Switzerland: Actual } I_{pd} \\text{ vs. convolution of deconvolution of } I_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nWe can see that our estimate for \\(\\hat{E}_{pd}\\) must be close to the reality of \\(E_{pd}\\) as \\(I_{pd}\\) is almost identical to \\(\\hat{E}_{pd} \\circledast h_L\\).\nOf course, this holds only as long as our estimate of \\(h_L\\) is close to reality.\n\n\n3. \\(\\beta\\) and \\(R\\) from \\(E_{pd}\\) and \\(I\\)\nAs described above:\n\\[R = \\frac{E_{pd}}{\\gamma~I}\\]\n\n#collapse_hide\n\n# Calculate R\ngam = 1/20.11 # As we say gamma is 1/20.11\nR = Enext[:len(inf_df.loc['Switzerland'])]*(1/gam)/inf_df.loc['Switzerland']\n\nfig = go.Figure(data=[    \n    go.Scatter(name='R', x=inf_df.loc['Switzerland'].index, y=R),\n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['Switzerland'].index, y=Enext),\n    go.Scatter(name='Inf', x=inf_df.loc['Switzerland'].index, y=inf_df.loc['Switzerland']),\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'R',\n    title={\n        'text':r'$\\text{Switzerland: R }$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n                                                \n\n\n\n\n\nUnited States\n\n1. Checking \\(h_I\\)\n\n\nCode\nfig = go.Figure(data=[    \n    go.Bar(name='Ipd', x=conf_df_pd.loc['US'].index, y=conf_df_pd.loc['US']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=conf_df_pd.loc['US'].index, y=lowpass(conf_df_pd.loc['US'], 0.05, 1)[0]),\n    go.Bar(name='Rpd', x=rec_df_pd.loc['US'].index, y=rec_df_pd.loc['US']),\n    go.Scatter(name='Rpd=lowpass(Rpd)', x=rec_df_pd.loc['US'].index, y=lowpass(rec_df_pd.loc['US'], 0.05, 1)[0]),\n    go.Scatter(name='Rpd=conv(Ipd)', x=conf_df_pd.loc['US'].index, y=signal.fftconvolve(h_I, conf_df_pd.loc['US'], mode='full'))\n])\n\nfig.update_layout(\n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{US: Actual } R_{pd} \\text{ vs. } h_I[j]\\circledast I_{pd}[j]$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\nData is not very good.\n\n\n2. Estimating \\(E_{pd}\\) by deconvolution of \\(I_{pd}\\)\n\n\nCode\n#Settting up for deconvolution of Ipd\n\n#regularization parameter\nalpha=2\n\n# Setup up the resultant Ipd we want to compare our guess with\nIpd=np.floor(lowpass(conf_df_pd.loc['US'], 0.05, 1)[0])\nIpd[Ipd&lt;0]=0\n\n\n# Pad with last value\ni=0\nwhile i &lt; 100:\n  Ipd=np.append(Ipd, Ipd[-1])\n  i=i+1\n\n# Find delay caused by h_L\ndelay=Ipd.argmax()-signal.fftconvolve(Ipd, h_L, mode='full').argmax()\n\nif (np.abs(delay)&gt;20):\n  delay = -15\n\n# We want initial guess to simply be the result of the convolution delayed\ninitial_guess=np.roll(Ipd,delay)\nEnext = initial_guess\n\n# AN array to record MSE between result we want and our iterated guess\nmse=np.array([])\nmse=np.append(mse, 10000000)\nmse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['US'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['US'])]))\n\nitercount=0\nwhile mse[-1] &lt; mse[-2]:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  mse=np.append(mse, msecalc(Ipd[:len(conf_df_pd.loc['US'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['US'])]))\n  print(\"Iteration #\" + str(itercount) +\": MSE= \"+str(mse[itercount]))\nprint(\"Iteration #\" + str(itercount+1) +\": MSE= \"+str(mse[-1])+\" so we use the result of the previous iteration.\")\n\n\nIteration #1: MSE= 47992077.600439996 so we use the result of the previous iteration.\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n\nCode\n# We can keep going the iteration until lowest MSE\n\n#change alpha if you like\nalpha=2\n\ni=0\nwhile i &lt; 10:\n  itercount=itercount+1\n  Enext=iter_deconv(alpha, h_L, Enext, delay, Ipd)\n  print(msecalc(Ipd[:len(conf_df_pd.loc['US'])], signal.fftconvolve(h_L, Enext, mode='full')[:len(conf_df_pd.loc['US'])]))\n  i=i+1\n\n\n22255749.4520845\n13474646.870988503\n9247852.125484189\n6845961.888525094\n5353233.801469828\n4373948.068754885\n3688854.4786455603\n3193666.3164928\n2820280.9677202436\n2533321.732436159\n\n\n\n\nCode\nfig = go.Figure(data=[    \n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['US'].index, y=Enext),\n    go.Scatter(name='Ipd=conv(deconv(Ipd))', x=inf_df.loc['US'].index, y=signal.fftconvolve(h_L, Enext, mode='full')),\n    go.Bar(name='Ipd', x=inf_df.loc['US'].index, y=conf_df_pd.loc['US']),\n    go.Scatter(name='Ipd=lowpass(Ipd)', x=inf_df.loc['US'].index, y=lowpass(conf_df_pd.loc['US'], 0.05, 1)[0])\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'Count',\n    title={\n        'text':r'$\\text{US: Actual } I_{pd} \\text{ vs. convolution of deconvolution of } I_{pd}$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n/tmp/ipykernel_17425/3295257807.py:10: FutureWarning:\n\nSeries.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n\n\n\n                                                \n\n\n\n\n3. \\(\\beta\\) and \\(R\\) from \\(E_{pd}\\) and \\(I\\)\nAs described above:\n\\[R = \\frac{E_{pd}}{\\gamma~I}\\]\n\n\nCode\n# Calculate R\ngam = 1/20.11 # As we say gamma is 1/20.11\nR = Enext[:len(inf_df.loc['US'])]*(1/gam)/inf_df.loc['US']\n\nfig = go.Figure(data=[    \n    go.Scatter(name='R', x=inf_df.loc['US'].index, y=R),\n    go.Scatter(name='Epd=deconv(Ipd)', x=inf_df.loc['US'].index, y=Enext),\n    go.Scatter(name='Inf', x=inf_df.loc['US'].index, y=inf_df.loc['US']),\n])\n\nfig.update_layout(\n    \n    xaxis_title = 'Day',\n    yaxis_title = 'R',\n    title={\n        'text':r'$\\text{US: R }$',\n        'x':0.5,\n        'xanchor':'center'\n    }\n)\n\nfig.show()\n\n\n\n                                                \n\n\nAfter March 15th we see a rapi decline in \\(R\\) until \\(R&lt;1\\) since April 12th, however the last 2 weeks of May have seen an increase and it is now close to 1 in early June.\nWe can see \\(R\\) declined rapidly after March 12th to \\(R&lt;1\\) on May 30th, but has since grown back to close to 1."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scattered Thoughts",
    "section": "",
    "text": "Epidemic modeling - Part 8\n\n\n\n\n\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\nstochastic\n\n\nCOVID-19\n\n\nreal-world\n\n\n\n\nStudying real-world data\n\n\n\n\n\n\nJun 2, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nHIV modeling\n\n\n\n\n\n\n\nprobability distributions\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\nstochastic\n\n\nHIV\n\n\nAIDS\n\n\n\n\nBuilding a new stochastic SEIR model to deal with probability distributions\n\n\n\n\n\n\nMay 7, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nHIV modeling\n\n\n\n\n\n\n\nprobability distributions\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\nstochastic\n\n\nHIV\n\n\nAIDS\n\n\n\n\nBuilding a new stochastic SEIR model to deal with probability distributions\n\n\n\n\n\n\nMay 5, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nTesting - what to be aware of\n\n\n\n\n\n\n\nCOVID-19\n\n\ntesting\n\n\nserology\n\n\n\n\nA common case used to identify gaps in knowledge on serology testing\n\n\n\n\n\n\nApr 12, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nEpidemic modeling - Part 7\n\n\n\n\n\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\nstochastic\n\n\nCOVID-19\n\n\n\n\nConvolution, deconvolution, and daily data\n\n\n\n\n\n\nApr 3, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nEpidemic modeling - Part 6\n\n\n\n\n\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\nstochastic\n\n\nCOVID-19\n\n\nreal-world\n\n\n\n\nA quick overview of control measures in times of pandemic/epidemic\n\n\n\n\n\n\nApr 2, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nEpidemic modeling - Part 5\n\n\n\n\n\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\nstochastic\n\n\nCOVID-19\n\n\nreproduction number\n\n\n\n\nFurther discussion on \\(R_0\\), distribution of \\(T_{Infectious}\\), and their impact on peak infectious in SEIR model\n\n\n\n\n\n\nApr 1, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nEpidemic modeling - Part 4\n\n\n\n\n\n\n\nprobability distributions\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\nstochastic\n\n\nCOVID-19\n\n\n\n\nBuilding a new stochastic SEIR model to deal with probability distributions\n\n\n\n\n\n\nMar 31, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nEpidemic modeling - Part 3\n\n\n\n\n\n\n\nprobability distributions\n\n\nmodeling\n\n\nSEIR\n\n\nepidemiology\n\n\n\n\nExamining the major flaw of the deterministic SEIR model\n\n\n\n\n\n\nMar 25, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nEpidemic modeling - Part 2\n\n\n\n\n\n\n\nmodeling\n\n\ncompartmentalization\n\n\nSEIR\n\n\nepidemiology\n\n\ndisease dynamics\n\n\n\n\nA deterministic numerical SEIR model\n\n\n\n\n\n\nMar 18, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nEpidemic modeling - Part 1\n\n\n\n\n\n\n\nmodeling\n\n\ncompartmentalization\n\n\nSEIR\n\n\nepidemiology\n\n\ndisease dynamics\n\n\n\n\nCompartmentalization models and disease dynamics\n\n\n\n\n\n\nMar 15, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\n  \n\n\n\n\nCOVID-19 Tracker Map\n\n\n\n\n\n\n\nCOVID-19\n\n\nDashboards\n\n\nPlotly\n\n\n\n\nA link to my COVID-19 map tracker\n\n\n\n\n\n\nMar 12, 2020\n\n\nJeffrey Post\n\n\n\n\n\n\nNo matching items"
  }
]